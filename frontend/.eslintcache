[{"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/index.js":"1","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/App.js":"2","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/splash.jsx":"3","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/gameView.jsx":"4","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/game.jsx":"5","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/classes/board.js":"6","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/board.jsx":"7","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/classes/player.js":"8","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/classes/boneyard.js":"9","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/bone.jsx":"10","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/hand.jsx":"11","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/arena.jsx":"12","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/allDominos.jsx":"13","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/otherHands.jsx":"14","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/classes/bone.js":"15","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/chat/join.js":"16","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/chat/chat.jsx":"17","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/chat/chatMsg.jsx":"18","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/chat/chatContext.jsx":"19","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/constructBone.jsx":"20"},{"size":587,"mtime":1610390935912,"results":"21","hashOfConfig":"22"},{"size":726,"mtime":1609970509930,"results":"23","hashOfConfig":"22"},{"size":3342,"mtime":1609970509944,"results":"24","hashOfConfig":"22"},{"size":231,"mtime":1609970509943,"results":"25","hashOfConfig":"22"},{"size":2143,"mtime":1610390945677,"results":"26","hashOfConfig":"22"},{"size":14681,"mtime":1610391068473,"results":"27","hashOfConfig":"22"},{"size":4799,"mtime":1610390945670,"results":"28","hashOfConfig":"22"},{"size":1259,"mtime":1610391037900,"results":"29","hashOfConfig":"22"},{"size":1669,"mtime":1609261284051,"results":"30","hashOfConfig":"22"},{"size":6212,"mtime":1610391008435,"results":"31","hashOfConfig":"22"},{"size":1714,"mtime":1610390945671,"results":"32","hashOfConfig":"22"},{"size":14827,"mtime":1610390945669,"results":"33","hashOfConfig":"22"},{"size":3444,"mtime":1609970509942,"results":"34","hashOfConfig":"22"},{"size":8189,"mtime":1610390945671,"results":"35","hashOfConfig":"22"},{"size":621,"mtime":1609970509940,"results":"36","hashOfConfig":"22"},{"size":912,"mtime":1609970509942,"results":"37","hashOfConfig":"22"},{"size":1742,"mtime":1609970509941,"results":"38","hashOfConfig":"22"},{"size":172,"mtime":1609261284052,"results":"39","hashOfConfig":"22"},{"size":717,"mtime":1609971631914,"results":"40","hashOfConfig":"22"},{"size":682,"mtime":1610390945670,"results":"41","hashOfConfig":"22"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"218tk5",{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"53","messages":"54","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"55","messages":"56","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"57","usedDeprecatedRules":"46"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"60","usedDeprecatedRules":"46"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"63","messages":"64","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"65","usedDeprecatedRules":"46"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"68","usedDeprecatedRules":"46"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"71","usedDeprecatedRules":"46"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"76","usedDeprecatedRules":"46"},{"filePath":"77","messages":"78","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"79","messages":"80","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"81","messages":"82","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"83","messages":"84","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"85","usedDeprecatedRules":"46"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"88","messages":"89","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/index.js",[],"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/App.js",[],["90","91"],"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/splash.jsx",[],"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/gameView.jsx",[],"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/game.jsx",[],"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/classes/board.js",["92","93","94"],"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/board.jsx",["95","96"],"import React from \"react\";\nimport Konva from \"konva\"\nimport { Stage, Layer, Group} from 'react-konva';\nimport Bone from \"./bone\"\nimport Hand from \"./hand\"\nimport Arena from \"./arena\"\nimport OtherHands from \"./otherHands\"\n\nimport { allDominos } from \"./allDominos\"\n\n\nclass Board extends React.Component {\n    constructor(props){\n        super(props)\n\n\n    }\n\n    componentDidMount(){\n        // this.getNums()\n    }\n\n    attachImages(){\n        // const\n    }\n\n    \n\n    render(){\n        const boardDimen = 900;\n        const boneWidth = 30;\n        const boneHeight = 60;\n        const boneIsRevYPos = (boneWidth / 2);\n        const boneNotRevYPos = ((boneWidth / 2) * 3);\n\n        const {board} = this.props;\n\n        const capDom = [<Bone key={\"cd\"}\n                    draggable={true}\n                    x={0}\n                    width={boneWidth}\n                    height={boneHeight}\n                    offsetX={boneWidth / 2}\n                    offsetY={boneHeight / 2}\n                    src={allDominos[\"cd\"]}\n                    rotation={0}\n                    inArena={true} />]\n\n        \n\n        // these 3 lines are required to center the arena in the middle of the board\n        // for Konva Group\n        const currArenaLength = board.arena.length\n        const offSetCenterArena = ((currArenaLength / 2) * boneWidth)  // mult by 40\n        const startBoxforArena = ((boardDimen / 2) - offSetCenterArena)\n\n        const boneValToString = (boneVal) => {\n            let firstNumStr = boneVal[0].toString();\n            let secondNumStr = boneVal[1].toString();\n            let boneValStrA = firstNumStr + secondNumStr;\n            let boneValStrB = secondNumStr + firstNumStr;\n\n            // The Idea here is the Top num is always on the left even when\n            // rotated -90 Degrees.\n            // ~\n            // If the bone has been rotated then it is boneValStrB and we\n            // can add rotational Logic to the front End.\n            return [boneValStrA, boneValStrB]\n        }\n\n        \n\n            \n        // These will determine the length of the playerID owner's hand and render them\n        // centered in the right place. We use startBoxforHand to pick a \n        // startX for the rendering of <Hand></Hand>\n        const currHandLength = board.currentPlayer.hand.length\n        // mult by 40 because width of bone is 30 plus 10 more pixels of space\n        const offSetCenter = ((currHandLength / 2) * boneWidth + 10)  \n\n        const startBoxforHand = ((boardDimen / 2) - offSetCenter)\n\n            \n           \n            // the arena is simply to show the current pieces in play\n        return (\n            <div className=\"board-game-container\">\n            <Stage width={boardDimen} height={boardDimen}>\n                <Layer>\n                    <Group x={startBoxforArena} y={(boardDimen / 2) - boneHeight}>\n                        <Arena board={board} boardDimen={boardDimen}\n                         allDominos={allDominos} boneValToString={boneValToString}\n                         boneWidth={boneWidth} boneHeight={boneHeight}\n                         boneIsRevYPos={boneIsRevYPos}\n                         boneNotRevYPos={boneNotRevYPos}/>\n                    </Group>\n                    <Group x={startBoxforArena} y={(boardDimen / 2) + 60}>\n                        {capDom}\n                    </Group>\n                    <OtherHands board={board} boardDimen={boardDimen} allDominos={allDominos}\n                    boneWidth={boneWidth} boneHeight={boneHeight} boneValToString={boneValToString}/>\n                    <Group x={startBoxforHand} y={boardDimen - boneHeight}>\n\n                        <Hand offSetCenter={offSetCenter} board={board}\n                        boneWidth={boneWidth} boneHeight={boneHeight} \n                        updateGame={this.props.updateGame} allDominos={allDominos}\n                        boneValToString={boneValToString}  />\n                    </Group>\n                </Layer>\n            </Stage>\n          </div>\n        );\n    }\n}\n\n\n\n\n\n\nexport default Board;","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/classes/player.js",["97"],"// import bone from './bone'\n// const Bone = require('bone')\n\n\n\n\n\nclass Player {\n    constructor(username, board, isAI) {\n      this.username = username;\n      this.points = 0;\n      this.hand = [];\n      this.isAI = isAI ? true : false;\n      this.board = board;\n      this.playerInput = undefined;\n      // this.getPlayerInput()\n\n     \n    }\n\n    \n\n      // probably the master function\n      //update NOT THE MASTER FUNCTON. node is async\n    getPlayerInput(correctAnswer){\n        this.revealHand();\n        this.playerInput = correctAnswer\n\n    }\n\n    //replaced canMove with hasPlayableBone()\n    hasPlayableBones(){\n        const canMakeMove = this.hand.some((bone) =>{\n            return this.board.isBonePlayable(bone);\n        });\n\n        if (!canMakeMove) return false;\n        return true\n    }\n\n    drawBone(){\n      const newBone = this.hand.push(this.board.boneyard.bones.pop())\n      console.log(`Player drew ${this.hand[this.hand.length-1].boneVal}`)\n    }\n\n    \n    revealHand(){\n      let handString = \"\"\n        this.hand.forEach(bone => {\n          handString += `[${bone.boneVal[0]}, ${bone.boneVal[1]}], `\n        })\n\n        console.log(`${this.username}'s Hand: `)\n\n        console.log(`${handString}`)\n        \n    }\n}\n\n// let p1 = new Player(\"Mike\", \"board\")\n\nexport default Player;\n  // module.exports = Player;\n\n\n  // removeFromHand(bone) {\n  //   for(let idx in this.hand) {\n  //     let bone = this.hand[idx];\n\n  //     if ((domino.top_number == domino.top_number && domino.bottom_number == domino.bottom_number)\n  //         // board [1:n] == hand [1:n] && board [n:2] == hand [n:2]  hand [[],[],[],[],[],[]]\n  //       ||\n  //       (domino.top_number == domino.bottom_number && domino.bottom_number == domino.top_number)) {\n  //         delete domino;\n  //       }\n  //   }\n  // }\n\n","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/classes/boneyard.js",[],"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/bone.jsx",["98"],"import React from \"react\";\nimport {Image} from 'react-konva';\n\nclass Bone extends React.Component {\n    constructor(props){\n        super(props)\n\n        this.state = {\n             board: null,\n             image: null,\n             draggable: null,\n             offSetCenter: null,\n             updateGame: null,\n             boneIdx: null,\n             rotation: null,\n             inArena: null,\n             x: null,\n             y: null,\n             width: null,\n             height: null,\n             offsetX: 0,\n             offsetY: 0\n        };\n\n\n    }\n    \n  componentDidMount() {\n    this.loadImage();\n  }\n\n  componentDidUpdate(oldProps) {\n    if (oldProps.src !== this.props.src) {\n      this.loadImage();\n    } \n    if (oldProps.x !== this.props.x){\n      this.loadImage();\n    } \n    if (oldProps.y !== this.props.y){\n      this.loadImage();\n    } \n    \n    \n  }\n\n  componentWillUnmount() {\n    this.image.removeEventListener('load', this.handleLoad);\n  }\n\n  loadImage() {\n    // save to \"this\" to remove \"load\" handler on unmount\n    this.image = new window.Image();\n    this.image.src = this.props.src;\n    this.image.addEventListener('load', this.handleLoad);\n  }\n\n  handleLoad = () => {\n    // after setState react-konva will update canvas and redraw the layer\n    // because \"image\" property is changed\n    // debugger\n    this.setState({\n      board: this.props.board,\n      image: this.image,\n      draggable: this.props.draggable,\n      offSetCenter: this.props.offSetCenter,\n      updateGame: this.props.updateGame,\n      boneIdx: this.props.boneIdx,\n      rotation: this.props.rotation,\n      inArena: this.props.inArena,\n      x: this.props.x,\n      y: this.props.y,\n      width: this.props.width,\n      height: this.props.height,\n      offsetX: this.props.offsetX,\n      offsetY: this.props.offsetY\n    });\n    // if you keep same image object during source updates\n    // you will have to update layer manually:\n    // this.imageNode.getLayer().batchDraw();\n  };\n\n\n  mouseDownStartCoord(e){\n\n    console.log(`MDX: ${e.target.attrs.x}`)\n    console.log(`MDY: ${e.target.attrs.y}`)\n    console.log(\"------\")\n  }\n\n  // decides where the player wants to play\n  mouseUpCoord(e, updateGame) {\n      debugger\n      const xPosPlay = e.target.attrs.x \n      const center = e.target.attrs.offSetCenter\n\n\n      //to use Konva indexing per group. use below\n      const boneIdx = e.target.index\n\n      // to use props it's this below\n      // const boneIdx = e.target.attrs.boneIdx\n\n      const yCoord = e.target.attrs.y\n      \n      console.log(`BoneIdxIs: ${e.target.attrs.boneIdx}`)\n\n      console.log(`Center: ${e.target.attrs.offSetCenter}`)\n      console.log(`X: ${e.target.attrs.x}`)\n      console.log(`Y: ${e.target.attrs.y}`)\n\n\n      // Remember to remove the left side of IF statement\n      // for testing only\n      // ******************************\n      // ******************************\n      // ******************************\n      // ******************************\n      // ******************************\n      // ******************************\n      // ******************************\n      \n      // if (!this.props.inArena && yCoord < -50) {\n      // if\n      if (this.state.board.arena.length <= 15){\n        if (yCoord < -50) {\n\n            updateGame(xPosPlay, center, boneIdx);\n        }\n\n      } else {\n        const halfBoardHeight = e.target.getCanvas().height / 2;\n        const absPos = e.target.getAbsolutePosition();\n        console.log(`AbsPos: x:${absPos.x} y: ${absPos.y}`)\n\n        if (yCoord < -50){\n          if (absPos.y < halfBoardHeight){\n            updateGame(absPos.y, halfBoardHeight, boneIdx);\n        } else {\n            updateGame(absPos.y, halfBoardHeight, boneIdx);\n        }\n        }\n        \n\n\n\n\n      }\n      \n          // console.log(e.target)\n    }\n\n    \n    slideUp(e){\n      // debugger\n      console.log(`thisX: ${e.target.attrs.x}`)\n      console.log(`thisY: ${e.target.attrs.y}`)\n      console.log(this.absolutePosition())\n      \n      if(!this.attrs.inArena){\n        this.to({\n          scaleX: 1.2,\n          scaleY: 1.2,\n          y: -20,\n          duration: 0.2\n        });\n        // this.getLayer().batchDraw();\n      }\n        \n    }\n\n    slideDown(e){\n      if(!this.attrs.inArena){\n          this.to({\n            scaleX: 1.0,\n            scaleY: 1.0,\n            y: 0,\n            duration: 0.2\n          });\n        // this.getLayer().batchDraw();\n      }\n      \n    }\n\n    //this FN disallows a domino to be dragged outside of the board\n    enforceBoundingBox(e){\n      const boneBox = e.target.getClientRect()\n      const absPos = e.target.getAbsolutePosition();\n      \n      // save the old position at any given time with x and y\n      const newAbsPos = {...absPos}\n      const boardWidth = e.target.getCanvas().width;\n      const boardHeight = e.target.getCanvas().height;\n      \n      \n      if (boneBox.x < 0) {\n        newAbsPos.x = 0;\n      }\n      if (boneBox.y < 0) {\n        newAbsPos.y = 0;\n      }\n      if (boneBox.x + boneBox.width > boardWidth) {\n        newAbsPos.x = boardWidth - boneBox.width;\n      }\n      if (boneBox.y + boneBox.height > boardHeight) {\n        newAbsPos.y = boardHeight - boneBox.height\n      }\n\n      // console.log(`newAbsPos: x:${newAbsPos.x} y: ${newAbsPos.y}`)\n\n      e.target.setAbsolutePosition(newAbsPos)\n\n    }\n\n    \n\n\n  render() {\n\n\n\n    \n    return (\n      <Image\n        board={this.state.board}\n        x={this.state.x}\n        y={this.state.y}\n        offSetCenter={this.state.offSetCenter}\n        image={this.state.image}\n        width={this.state.width}\n        height={this.state.height}\n        boneIdx={this.state.boneIdx}\n        offsetX={this.state.offsetX}\n        offsetY={this.state.offsetY}\n        draggable={this.state.draggable}\n        onMouseDown={this.mouseDownStartCoord}\n        onMouseOver={this.slideUp}\n        onMouseOut={this.slideDown}\n        onDragEnd={(e) => this.mouseUpCoord(e, this.state.updateGame)}\n        onDragMove={this.enforceBoundingBox}\n        rotation={this.state.rotation}\n        inArena={this.state.inArena}\n        ref={node => {\n          this.imageNode = node;\n        }}\n      />\n    );\n  }\n}\n\nexport default Bone;\n\n\n\n\n\n","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/hand.jsx",["99"],"import React from \"react\";\nimport {Group} from 'react-konva';\nimport Bone from \"./bone\"\n\n\n\nclass Hand extends React.Component {\n\n\n    render(){\n        const {board, allDominos, boneValToString, offSetCenter,\n        boneWidth, boneHeight} = this.props;\n\n\n        // this will need to be changed to the axios player ID. \n        // SOLELY FOR TESTING...\n        let renderedHand = [];\n\n        if (board){\n\n            renderedHand = board.currentPlayer.hand.map((bone,idx) => {\n\n               const singleBoneVal =  boneValToString(bone.boneVal)[0]\n               const reactKeyVal = parseInt(singleBoneVal)\n               const initialX = 0;\n\n               //width of domino plus spacing\n               const width = (boneWidth + 10);\n\n                const pos = initialX + (width * idx);\n\n                return <Bone \n                x={pos} \n                width={boneWidth}\n                height={boneHeight}\n                updateGame={this.props.updateGame}\n                boneIdx={idx}\n                offSetCenter={offSetCenter}\n                draggable={true}\n                key={reactKeyVal}\n                src={allDominos[singleBoneVal]}\n                inArena={false}/>    \n            })\n\n        }\n\n         return(\n                <>          \n                 {renderedHand}\n                </>\n         )\n\n    }\n\n}\nexport default Hand;","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/arena.jsx",["100","101"],"import React from \"react\";\nimport Konva from \"konva\";\nimport Bone from \"./bone\";\n\n\n\n\n\n\n\n\n\nclass Arena extends React.Component {\n\n    render(){\n        const {board, boneValToString, allDominos, boardDimen,\n        boneWidth, boneHeight, boneIsRevYPos, boneNotRevYPos } = this.props;\n\n\n        // we need the keys of all possible dominos to be rendered\n        // allDominosArr is then keyed into with boneValToString to retrieve\n        // The appropriate Domino Image\n        const allDominosArr = Object.keys(allDominos);\n\n        //this function returns a bone with the x position always at zero\n        //unless the bone is Reversed. then X is +60 because Konva\n        //offsets +90 degree rotation in the negative x-axis.\n        const isFirstBone = (isDouble, isReversed, boneStrArr, reactKeyVal) => {\n            if (isDouble){\n                return <Bone key={reactKeyVal}\n                draggable={true}\n                x={0}\n                width={boneWidth}\n                height={boneHeight}\n                // offsetX={boneWidth / 2}\n                src={allDominos[boneStrArr[0]]}\n                rotation={0}\n                inArena={true} />\n            } else if (isReversed){\n                //boneVal has been reversed. Rotate 90 Degrees\n                // prop x is shifted 60 pixels to the right because rotation\n                // auto-shifts it 60 pixels to the left??? (due to Konva)\n                return <Bone key={reactKeyVal} \n                    draggable={true}\n                    x={boneHeight}\n                    y={boneIsRevYPos}\n                    width={boneWidth}\n                    height={boneHeight}\n                    src={allDominos[boneStrArr[1]]} \n                    rotation={90}\n                    inArena={true} /> \n            } else {\n                //boneVal is NOT reversed. Rotate -90 Degrees\n                 return <Bone key={reactKeyVal}\n                    draggable={true}\n                    x={0}\n                    y={boneNotRevYPos}\n                    width={boneWidth}\n                    height={boneHeight}\n                    src={allDominos[boneStrArr[0]]}\n                    rotation={-90}\n                    inArena={true} />\n            }\n        }\n\n        const xLengthAllBones = (boneDimenArr, currIdx) => {\n            let totalXPos = 0;\n\n            for(let i = 0; i < currIdx; i++){\n                totalXPos += boneDimenArr[i].x;\n            }\n\n            return totalXPos;\n        }\n\n        const boneDimenArr = [];\n\n        const arena = board.arena.map((bone, idx) => {\n            const boneStrArr = boneValToString(bone.boneVal);\n\n            const singleBoneVal =  boneStrArr[0];\n            const reactKeyVal = parseInt(singleBoneVal);\n\n            const boneXnY = (\n                bone.isDouble() ? {\n                    isDouble: true,\n                    isReversed: false,\n                    boneStrArr: boneStrArr,\n                    reactKeyVal: reactKeyVal,\n                    x: boneWidth,\n                    y: 0} :\n                (bone.isReversed ? {\n                    isDouble: false,\n                    isReversed: true,\n                    boneStrArr: boneStrArr,\n                    reactKeyVal: reactKeyVal,\n                    x: boneHeight,\n                    y: boneIsRevYPos } : \n                    {\n                    isDouble: false,\n                    isReversed: false,\n                    boneStrArr: boneStrArr,\n                    reactKeyVal: reactKeyVal, \n                    x: boneHeight, \n                    y: boneNotRevYPos\n                    })\n                );\n\n            boneDimenArr.push(boneXnY);\n\n        \n            if (idx === 0){\n                // debugger\n                return isFirstBone(\n                     boneDimenArr[0].isDouble,\n                     boneDimenArr[0].isReversed,\n                     boneDimenArr[0].boneStrArr,\n                     boneDimenArr[0].reactKeyVal)\n            } else {\n\n                if (bone.isDouble()){\n                    const totalXPos = xLengthAllBones(boneDimenArr, idx);\n                    console.log(`totalXPOS: ${totalXPos}`)\n\n                    // debugger\n                    return <Bone key={reactKeyVal}\n                    draggable={true}\n                    x={totalXPos}\n                    width={boneWidth}\n                    height={boneHeight}\n                    src={allDominos[boneStrArr[0]]}\n                    rotation={0}\n                    inArena={true} />\n                }\n                else if(allDominosArr.includes(boneStrArr[0])){\n                    // bone is NOT reversed\n                    //rotate once -90 degrees\n                    const totalXPos = xLengthAllBones(boneDimenArr, idx);\n                    // debugger\n                    return <Bone key={reactKeyVal} \n                    draggable={true}\n                    x={totalXPos}\n                    y={boneNotRevYPos}\n                    width={boneWidth}\n                    height={boneHeight}\n                    src={allDominos[boneStrArr[0]]}\n                    rotation={-90}\n                    inArena={true} />\n                } else {\n                    //boneVal has been reversed. Rotate 90 Degrees\n                    const totalXPos = xLengthAllBones(boneDimenArr, idx) + 60;\n                    \n                    // debugger\n                    return <Bone key={reactKeyVal}\n                    draggable={true}\n                    x={totalXPos}\n                    y={boneIsRevYPos}\n                    width={boneWidth}\n                    height={boneHeight}\n                    src={allDominos[boneStrArr[1]]}\n                    rotation={90}\n                    inArena={true} />\n                }\n            }\n\n        })\n\n\n        return (\n            <>\n            {arena}\n            </>\n        )\n    }\n}\n\nexport default Arena;","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/allDominos.jsx",[],"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/otherHands.jsx",["102","103","104"],"import React from \"react\";\nimport {Group} from 'react-konva';\nimport Bone from \"./bone\"\n\n\n\nclass OtherHands extends React.Component {\n\n\n    render() {\n        const {board, boardDimen, boneWidth,\n            boneHeight, boneValToString, allDominos} = this.props;\n\n        const renderHandFn = (player, offSetCenter, playerIdx, currPlayerIdx) => {\n            // debugger\n            \n         const renderedHand = player.hand.map((bone,idx) => {\n\n            const singleBoneVal =  boneValToString(bone.boneVal)[0]\n            const reactKeyVal = parseInt(singleBoneVal + playerIdx)\n            const initialX = 0;\n            const initialY = 0;\n\n            //width of domino plus spacing\n            const width = boneWidth + 10;\n\n            let pos = initialX + (width * idx);\n\n            // debugger\n            \n            // if ((((currPlayerIdx % board.players.length) + 1) % board.players.length)  === playerIdx % board.players.length){\n            if (((currPlayerIdx + 1) % board.players.length)  === playerIdx % board.players.length){\n\n                pos = initialY + (width * idx);\n\n                // width and height are reversed because the bone is flat\n                return <Bone \n                x={0}\n                y={pos} \n                width={boneHeight}\n                height={boneWidth}\n                boneIdx={idx}\n                offSetCenter={offSetCenter}\n                draggable={true}\n                key={reactKeyVal}\n                src={allDominos[\"cdl\"]}\n                inArena={true}/> \n            } \n            else if(((currPlayerIdx + 2) % board.players.length) === playerIdx % board.players.length){\n            \n                return <Bone \n                x={pos}\n                y={0} \n                width={boneWidth}\n                height={boneHeight}\n                boneIdx={idx}\n                offSetCenter={offSetCenter}\n                draggable={true}\n                key={reactKeyVal}\n                src={allDominos[\"cdt\"]}\n                inArena={true}/> \n            }\n            else if(((currPlayerIdx + 3) % board.players.length) === playerIdx % board.players.length){\n                pos = initialY + (width * idx);\n\n                return <Bone \n                x={0}\n                y={pos} \n                width={boneHeight}\n                height={boneWidth}\n                boneIdx={idx}\n                offSetCenter={offSetCenter}\n                draggable={true}\n                key={reactKeyVal}\n                src={allDominos[\"cdr\"]}\n                inArena={true}/> \n            }\n               \n        })\n\n            return renderedHand\n        }\n\n        const currPlayerIdx = board.players.indexOf(board.currentPlayer);\n\n        const blankDominoToCoveredHands = (numPlayers, currPlayerIdx) => {\n            let player2Idx = null;\n            let player3Idx = null;\n            switch(numPlayers){\n                case 2:\n                    player2Idx = ((currPlayerIdx + 1) % board.players.length);\n                    return {[player2Idx]: \"cdt\",\n                            [currPlayerIdx]: \"cdt\"}\n                case 3:\n                     player2Idx = ((currPlayerIdx + 1) % board.players.length);\n                     player3Idx = ((currPlayerIdx + 2) % board.players.length);\n                    return {[player2Idx]: \"cdl\",\n                            [player3Idx]: \"cdt\",\n                            [currPlayerIdx]: \"cdt\"}\n                case 4:\n\n                default:\n                    return\n            }\n        }\n        \n        // allPlayers[someIdx]\n        //The important thing here is that the index to access allPlayers Obj will\n        // always match the index of the next player (p2) and beyond regardless of\n        // where the currentPlayer index is...\n        const allPlayersDataObj = (numPlayers, currPlayerIdx) => {\n            let allPlayers = {};\n\n            /* all the metadata necessary to populate the hidden hands\n               - offSetCenter is the midpoint of board minus the total width of all bones\n                   to center the hand on the board regardless of length\n                - startBoxforPlayerHand is the start x or start y of this div on\n                  the board. relative to board (x,y) @ (0,0)\n                - renderedHandPlayer is a collection of ImageNodes of the count \n                  of all bones in that players hand.\n            */\n            for(let i = currPlayerIdx; i < (currPlayerIdx + numPlayers); i++){\n                allPlayers[i % numPlayers] = {\n                    playerIdx: null,\n                    player: null,\n                    playerHand: null,\n                    offSetCenter: null,\n                    startBoxforPlayerHand: null,\n                    renderedHandPlayer: null\n                         \n                }\n            }\n\n            // this for loop builds out metadata per player to be accessed later \n            //by the function gnerateHands\n            for(let j = currPlayerIdx; j < (currPlayerIdx + numPlayers); j++){\n\n                allPlayers[j % numPlayers].playerIdx = (j % numPlayers);\n                allPlayers[j % numPlayers].player = board.players[allPlayers[j % numPlayers].playerIdx];\n                allPlayers[j % numPlayers].playerHand = allPlayers[j % numPlayers].player.hand;\n                allPlayers[j % numPlayers].offSetCenter = ((allPlayers[j % numPlayers].playerHand.length / 2) * 40);\n                allPlayers[j % numPlayers].startBoxforPlayerHand = ((boardDimen / 2) - allPlayers[j % numPlayers].offSetCenter);\n                allPlayers[j % numPlayers].renderedHandPlayer = renderHandFn(allPlayers[j % numPlayers].player,\n                         allPlayers[j % numPlayers].offSetCenter,\n                         allPlayers[j % numPlayers].playerIdx, currPlayerIdx)\n                \n                }\n\n            return allPlayers;\n\n        }\n\n        const allPlayers = allPlayersDataObj(board.players.length, currPlayerIdx)\n\n        const generateHands = (numPlayers, websocketsId) => {\n                // debugger\n            \n            // const player2Idx = ((currPlayerIdx + 1) % board.players.length);\n            // const player2 = board.players[player2Idx];\n            // const player2Hand = player2.hand;\n            // const offSetCenterP2 = ((player2Hand.length / 2) * 40);\n            // const startBoxforPlayer2Hand = ((boardDimen / 2) - offSetCenter);  \n\n            // const renderedHandplayer2 = renderHandFn(player2, offSetCenter, player2Idx, \"cdt\")\n            const player2Idx = ((currPlayerIdx + 1) % board.players.length);\n            const player3Idx = ((currPlayerIdx + 2) % board.players.length);\n            const player4Idx = ((currPlayerIdx + 3) % board.players.length);\n            switch(numPlayers){\n                case 2:\n        \n                    return <Group x={0} y={allPlayers[player2Idx].startBoxforPlayerHand}> \n                                {allPlayers[player2Idx].renderedHandPlayer}\n\n                            </Group>\n                case 3:\n                    \n                     return <Group x={0} y={0}>\n                                {/* player on left of board below */}\n                                <Group x={0} y={allPlayers[player2Idx].startBoxforPlayerHand}> \n                                    {allPlayers[player2Idx].renderedHandPlayer}\n                                </Group>\n                                {/* player on top of board below */}\n                                <Group x={allPlayers[player3Idx].startBoxforPlayerHand} y={0}>\n                                    {allPlayers[player3Idx].renderedHandPlayer}\n                                </Group>\n                            </Group>\n                case 4:\n                \n                    return <Group x={0} y={0}>\n                                {/* player on left of board below */}\n                                <Group x={0} y={allPlayers[player2Idx].startBoxforPlayerHand}> \n                                    {allPlayers[player2Idx].renderedHandPlayer}\n                                </Group>\n                                {/* player on top of board below */}\n                                <Group x={allPlayers[player3Idx].startBoxforPlayerHand} y={0}>\n                                    {allPlayers[player3Idx].renderedHandPlayer}\n                                </Group>\n                                {/* player on right of board below */}\n                                <Group x={boardDimen - boneHeight} y={allPlayers[player4Idx].startBoxforPlayerHand}>\n                                    {allPlayers[player4Idx].renderedHandPlayer}\n                                </Group>\n                           </Group>\n\n                default:\n                    return <Group></Group>\n            }\n\n        }\n        let handsToGenerate = null;\n        if(board){\n            handsToGenerate = generateHands(board.players.length);\n\n        }\n\n        return (\n            <>\n            {handsToGenerate}\n            </>\n        )\n    }\n}\n export default OtherHands;\n","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/classes/bone.js",[],"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/chat/join.js",[],"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/chat/chat.jsx",[],"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/chat/chatMsg.jsx",["105"],"import React from 'react'\n\nexport default ({ name, message }) =>\n  <>\n    <div className=\"send-textarea\">\n      <strong>{name}:</strong> <em>{message}</em>\n    </div>\n  </>","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/chat/chatContext.jsx",[],"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/constructBone.jsx",[],{"ruleId":"106","replacedBy":"107"},{"ruleId":"108","replacedBy":"109"},{"ruleId":"110","severity":1,"message":"111","line":6,"column":1,"nodeType":"112","messageId":"113","endLine":17,"endColumn":2},{"ruleId":"114","severity":1,"message":"115","line":399,"column":58,"nodeType":"116","messageId":"117","endLine":399,"endColumn":59},{"ruleId":"114","severity":1,"message":"115","line":399,"column":68,"nodeType":"116","messageId":"117","endLine":399,"endColumn":69},{"ruleId":"118","severity":1,"message":"119","line":2,"column":8,"nodeType":"120","messageId":"121","endLine":2,"endColumn":13},{"ruleId":"122","severity":1,"message":"123","line":13,"column":5,"nodeType":"124","messageId":"125","endLine":17,"endColumn":6},{"ruleId":"118","severity":1,"message":"126","line":41,"column":13,"nodeType":"120","messageId":"121","endLine":41,"endColumn":20},{"ruleId":null,"fatal":true,"severity":2,"message":"127","line":155,"column":2},{"ruleId":"118","severity":1,"message":"128","line":2,"column":9,"nodeType":"120","messageId":"121","endLine":2,"endColumn":14},{"ruleId":"118","severity":1,"message":"119","line":2,"column":8,"nodeType":"120","messageId":"121","endLine":2,"endColumn":13},{"ruleId":"118","severity":1,"message":"129","line":16,"column":52,"nodeType":"120","messageId":"121","endLine":16,"endColumn":62},{"ruleId":"130","severity":1,"message":"131","line":17,"column":58,"nodeType":"132","messageId":"133","endLine":17,"endColumn":60},{"ruleId":"118","severity":1,"message":"134","line":86,"column":15,"nodeType":"120","messageId":"121","endLine":86,"endColumn":40},{"ruleId":"135","severity":1,"message":"136","line":102,"column":17,"nodeType":"137","messageId":"138","endLine":103,"endColumn":27},{"ruleId":"139","severity":1,"message":"140","line":3,"column":1,"nodeType":"141","endLine":8,"endColumn":6},"no-native-reassign",["142"],"no-negated-in-lhs",["143"],"no-extend-native","Array prototype is read only, properties should not be added.","AssignmentExpression","unexpected","no-useless-concat","Unexpected string concatenation of literals.","BinaryExpression","unexpectedConcat","no-unused-vars","'Konva' is defined but never used.","Identifier","unusedVar","no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","'newBone' is assigned a value but never used.","Parsing error: Unexpected token\n\n\u001b[0m \u001b[90m 153 | \u001b[39m    slideUp(e){\u001b[0m\n\u001b[0m \u001b[90m 154 | \u001b[39m      \u001b[90m// debugger\u001b[39m\u001b[0m\n\u001b[0m\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 155 | \u001b[39m\u001b[33m<<\u001b[39m\u001b[33m<<\u001b[39m\u001b[33m<<\u001b[39m\u001b[33m<\u001b[39m \u001b[33mHEAD\u001b[39m\u001b[0m\n\u001b[0m \u001b[90m     | \u001b[39m \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\u001b[0m\n\u001b[0m \u001b[90m 156 | \u001b[39m      \u001b[90m// console.log(this.getPosition())\u001b[39m\u001b[0m\n\u001b[0m \u001b[90m 157 | \u001b[39m\u001b[33m===\u001b[39m\u001b[33m===\u001b[39m\u001b[33m=\u001b[39m\u001b[0m\n\u001b[0m \u001b[90m 158 | \u001b[39m      console\u001b[33m.\u001b[39mlog(\u001b[32m`thisX: ${e.target.attrs.x}`\u001b[39m)\u001b[0m","'Group' is defined but never used.","'boardDimen' is assigned a value but never used.","array-callback-return","Array.prototype.map() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","'blankDominoToCoveredHands' is assigned a value but never used.","no-fallthrough","Expected a 'break' statement before 'default'.","SwitchCase","default","import/no-anonymous-default-export","Assign arrow function to a variable before exporting as module default","ExportDefaultDeclaration","no-global-assign","no-unsafe-negation"]