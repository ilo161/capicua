[{"/Users/yangel/Desktop/capicua/capicua/frontend/src/classes/boneyard.js":"1","/Users/yangel/Desktop/capicua/capicua/frontend/src/components/game.jsx":"2","/Users/yangel/Desktop/capicua/capicua/frontend/src/App.js":"3","/Users/yangel/Desktop/capicua/capicua/frontend/src/classes/board.js":"4","/Users/yangel/Desktop/capicua/capicua/frontend/src/classes/player.js":"5","/Users/yangel/Desktop/capicua/capicua/frontend/src/components/bone.jsx":"6","/Users/yangel/Desktop/capicua/capicua/frontend/src/components/board.jsx":"7","/Users/yangel/Desktop/capicua/capicua/frontend/src/classes/bone.js":"8","/Users/yangel/Desktop/capicua/capicua/frontend/src/components/allDominos.jsx":"9","/Users/yangel/Desktop/capicua/capicua/frontend/src/index.js":"10","/Users/yangel/Desktop/capicua/capicua/frontend/src/components/hand.jsx":"11","/Users/yangel/Desktop/capicua/capicua/frontend/src/components/chat/chat.jsx":"12","/Users/yangel/Desktop/capicua/capicua/frontend/src/components/chat/chatMsg.jsx":"13","/Users/yangel/Desktop/capicua/capicua/frontend/src/components/chat/chatContext.jsx":"14","/Users/yangel/Desktop/capicua/capicua/frontend/src/components/gameView.jsx":"15","/Users/yangel/Desktop/capicua/capicua/frontend/src/components/splash.jsx":"16","/Users/yangel/Desktop/capicua/capicua/frontend/src/components/gameScore.jsx":"17","/Users/yangel/Desktop/capicua/capicua/frontend/src/components/gameRule.jsx":"18","/Users/yangel/Desktop/capicua/capicua/frontend/src/components/chat/join.js":"19","/Users/yangel/Desktop/capicua/capicua/frontend/src/components/arena.jsx":"20","/Users/yangel/Desktop/capicua/capicua/frontend/src/components/otherHands.jsx":"21"},{"size":1669,"mtime":1609265397152,"results":"22","hashOfConfig":"23"},{"size":2097,"mtime":1610131981541,"results":"24","hashOfConfig":"23"},{"size":734,"mtime":1610132047510,"results":"25","hashOfConfig":"23"},{"size":12615,"mtime":1610131981538,"results":"26","hashOfConfig":"23"},{"size":1817,"mtime":1610131981539,"results":"27","hashOfConfig":"23"},{"size":6516,"mtime":1610131981541,"results":"28","hashOfConfig":"23"},{"size":4069,"mtime":1610131981541,"results":"29","hashOfConfig":"23"},{"size":621,"mtime":1610131981538,"results":"30","hashOfConfig":"23"},{"size":3444,"mtime":1610131981540,"results":"31","hashOfConfig":"23"},{"size":574,"mtime":1610131951426,"results":"32","hashOfConfig":"23"},{"size":1364,"mtime":1610131981541,"results":"33","hashOfConfig":"23"},{"size":1742,"mtime":1609265397169,"results":"34","hashOfConfig":"23"},{"size":172,"mtime":1609265397153,"results":"35","hashOfConfig":"23"},{"size":717,"mtime":1609265765515,"results":"36","hashOfConfig":"23"},{"size":641,"mtime":1610131972369,"results":"37","hashOfConfig":"23"},{"size":3465,"mtime":1610131981550,"results":"38","hashOfConfig":"23"},{"size":1032,"mtime":1610131972368,"results":"39","hashOfConfig":"23"},{"size":874,"mtime":1610131972368,"results":"40","hashOfConfig":"23"},{"size":912,"mtime":1610131981539,"results":"41","hashOfConfig":"23"},{"size":5885,"mtime":1610131981540,"results":"42","hashOfConfig":"23"},{"size":9087,"mtime":1610131981542,"results":"43","hashOfConfig":"23"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"46","usedDeprecatedRules":"47"},"eftytw",{"filePath":"48","messages":"49","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50","usedDeprecatedRules":"47"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"53","messages":"54","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55","usedDeprecatedRules":"47"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"47"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"47"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"62","usedDeprecatedRules":"47"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"47"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"47"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"69","messages":"70","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"71","usedDeprecatedRules":"47"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"47"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"76","usedDeprecatedRules":"47"},{"filePath":"77","messages":"78","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"47"},{"filePath":"79","messages":"80","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"47"},{"filePath":"81","messages":"82","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"47"},{"filePath":"83","messages":"84","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"47"},{"filePath":"85","messages":"86","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"47"},{"filePath":"87","messages":"88","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"47"},{"filePath":"89","messages":"90","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"91","usedDeprecatedRules":"47"},{"filePath":"92","messages":"93","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"94","usedDeprecatedRules":"47"},"/Users/yangel/Desktop/capicua/capicua/frontend/src/classes/boneyard.js",["95","96"],"const Bone = require(\"./bone.js\")\n\n\nclass Boneyard {\n    constructor(board){\n        this.bones = this.generateBoneyard()\n        this.shuffleBoneYard(this.bones)\n        \n    }\n\n    //Function generates a 2 length string of Integer values that match the face of a Domino/Bone\n    getUniqueDominoNums(){\n        let dominoStrs = []\n\n        let i;\n        let j;\n        for (let i = 0; i < 7; i++) {\n            for (let j = i; j < 7; j++) {\n                dominoStrs.push(`${i}${j}`)\n            }\n        }\n\n        return dominoStrs\n    }\n\n    // Function generates an array of objects. Objects are Bone Objects from Bone.js. 28 total\n    generateBoneyard(){\n        let allBones;\n        let dominoNums = this.getUniqueDominoNums()\n\n        allBones = dominoNums.map((numberPair, idx) => {\n            return new Bone([parseInt(numberPair[0]),  parseInt(numberPair[1])])\n        })\n\n        return allBones\n    }\n\n\n    //Shuffles existing boneyard so that it is random. All 28\n    shuffleBoneYard(allBones){\n\n            for(let i = allBones.length - 1; i > 0; i--){\n                const randomMathFloorIdx = Math.floor(Math.random() * i)\n                const lastIdx = allBones[i]\n                const temp = allBones[randomMathFloorIdx]  \n                allBones[i] = temp;\n                allBones[randomMathFloorIdx] = lastIdx\n            }\n                return allBones\n    }\n\n    isEmpty(){\n        if (this.bones.length === 0){\n            return true\n        }\n        return false\n    }\n\n    // draws last bone from boneyard\n    draw(){\n        return this.bones.pop()\n    }\n\n\n    \n}\nmodule.exports = Boneyard\n\n",["97","98"],"/Users/yangel/Desktop/capicua/capicua/frontend/src/components/game.jsx",["99"],"import React from \"react\";\nimport Board from \"./board\"\nimport BoardObject from \"../classes/board\"\n// const BoardObject = require(\"../classes/board\")\n\nconst axiosPlayerObj = [{username: \"Steven\"}, {username: \"TinyPigOink!\"}]\n\nclass Game extends React.Component {\n    constructor(props){\n        super(props)\n        const board = new BoardObject(axiosPlayerObj)\n        this.state = {board: board}\n        this.updateGame = this.updateGame.bind(this);\n    }\n\n    componentDidMount(){\n        console.log(this.state.board)\n\n    }\n\n    updateGame(xPosPlay, center, boneIdx) { {/* connected to Tile Component line 8 */}\n        \n        const currentBone = this.state.board.currentPlayer.hand.splice(boneIdx,1)[0];\n        this.setState({ state: this.state });\n        const verifyMove = this.state.board.makeMove(xPosPlay, center, currentBone);\n\n        if(verifyMove){\n            this.setState({ board: this.state.board });\n\n        }else {\n\n            this.state.board.currentPlayer.hand.splice(boneIdx,0, currentBone); \n            this.setState({ board: this.state.board });\n\n            // this.forceUpdate();\n        }\n        //three arguments xPos, center, bone)\n        console.log(this.state.board.renderArena())\n        console.log(\"Arena ^..hand below\")\n        console.log(this.state.board.currentPlayer.hand)\n    }\n\n    render(){\n        \n\n        return (\n            <div className=\"board-container\">\n                <Board board={this.state.board} updateGame={this.updateGame}/>\n            </div>\n        )\n    }\n\n}\n\nexport default Game;","/Users/yangel/Desktop/capicua/capicua/frontend/src/App.js",["100"],"/Users/yangel/Desktop/capicua/capicua/frontend/src/classes/board.js",["101","102"],"const Boneyard = require(\"./boneyard\")\nconst Player = require(\"./player\")\n\nclass Board {\n    constructor(axiosPlayerData){\n        this.boneyard = new Boneyard(this);\n        this.arena = [];\n        this.players = this.generatePlayers(axiosPlayerData);\n        this.currentPlayer = undefined;\n        this.aIFirstMove = undefined;\n\n        this.inSession = true;\n        this.runningGame()\n        // debugger\n\n    }\n\n    //axiosPlayerData comes in as in Array\n    generatePlayers(axiosPlayerData){\n        const players = axiosPlayerData.map((playerData) => {\n\n            if (playerData.isAI){\n                return new Player(playerData.username, this, true );\n            }\n            return new Player(playerData.username, this );\n        })\n\n        return players\n    }\n\n    init(){\n        //distribute 7 bones to each player\n        this.startingHand();\n\n        // if boneyard has all 7 double Dominos. create new Boneyard obj\n        if (this.sevenDoubles()){\n            this.restartBoneYard();\n            this.init();\n        }\n\n        //set the currentPlayer to...\n        // returns playerIdx => boneIdxInHandOfDouble\n        let playerAndBoneIdx = this.decideFirstPlayer();\n\n        //check if player is AI\n        if (this.players[playerAndBoneIdx[0]].isAI){\n            debugger\n            //works...\n        }\n\n        return playerAndBoneIdx\n\n\n\n    }\n\n    /*\n    ********************************INITIALIZE BOARD FUNCTIONS START HERE**************\n    ********************************INITIALIZE BOARD FUNCTIONS START HERE**************\n    ********************************INITIALIZE BOARD FUNCTIONS START HERE**************\n    ********************************INITIALIZE BOARD FUNCTIONS START HERE**************\n    ********************************INITIALIZE BOARD FUNCTIONS START HERE**************\n    */\n\n    restartBoneYard(){\n        debugger\n        //empty boneyard and make new bones\n        this.boneyard = new Boneyard(this);\n    }\n\n    startingHand(){\n        //this function will iterate through the players in the game \n        // and distribute 7 bones to each player at random\n\n        this.players.forEach((player) => {\n            player.hand = [];\n\n            for(let i = 0; i < 7; i++){  \n                player.hand.push(this.boneyard.bones.pop());\n            }\n            \n            \n            //TESTING ONLY -- DELETE FOR PRODUCTION\n            console.log(`${player.username} below`)\n                player.hand.forEach(boneObj => {\n                    console.log(boneObj.boneVal);\n                })\n        });\n    }\n\n    //Checks to make sure at least one player has one double\n    sevenDoubles() {\n        let doubleBoneCounter = 0;\n        this.boneyard.bones.forEach(boneObj => {\n            if (boneObj.isDouble()) {\n                doubleBoneCounter++;\n            }\n        })\n        return doubleBoneCounter === 7 ? true : false;\n    }\n\n    decideFirstPlayer(){\n        //Automatically pick lowest Double Domino with => playerIdx => boneIdxInHand\n        let playerWithHighestDouble = ([[0, 0], null, null]);\n\n        this.players.forEach((player, playerIdx) => {\n            player.hand.forEach((bone, boneIdx) => {\n                // test only doubles\n                if (bone.isDouble()){\n                    playerWithHighestDouble = this.highestDouble(bone,\n                        playerWithHighestDouble,\n                        playerIdx,\n                        boneIdx)\n                    }\n                })\n            })\n\n        this.currentPlayer = this.players[playerWithHighestDouble[1]]\n        // debugger\n        //                  => playerIdx => boneIdxInHand\n        return [playerWithHighestDouble[1], playerWithHighestDouble[2]]\n\n    }\n\n    highestDouble(bone, currentHigh, currentPlayerIdx, boneIdx) {\n\n      if (bone.topNumber >= currentHigh[0][0]){\n        currentHigh = ([bone.boneVal, currentPlayerIdx, boneIdx]);\n        return currentHigh;\n      }\n      return currentHigh;\n    }\n\n    /*\n    ********************************INITIALIZE BOARD FUNCTIONS END HERE**************\n    ********************************INITIALIZE BOARD FUNCTIONS END HERE**************\n    ********************************INITIALIZE BOARD FUNCTIONS END HERE**************\n    ********************************INITIALIZE BOARD FUNCTIONS END HERE**************\n    ********************************INITIALIZE BOARD FUNCTIONS END HERE**************\n    */\n\n\n\n    /*\n    ********************************RUNNING GAMEPLAY FUNCTIONS START HERE**************\n    ********************************RUNNING GAMEPLAY FUNCTIONS START HERE**************\n    ********************************RUNNING GAMEPLAY FUNCTIONS START HERE**************\n    ********************************RUNNING GAMEPLAY FUNCTIONS START HERE**************\n    ********************************RUNNING GAMEPLAY FUNCTIONS START HERE**************\n    */\n\n    //Ensures currentPlayer plays highest Double\n    firstMoveAndCorrectBone(mandatoryBoneIdxToPlay){\n        this.arena.push(this.currentPlayer.hand.splice(mandatoryBoneIdxToPlay[1],1)[0]);\n        this.renderArena();\n    }\n\n    runningGame(){\n         const mandatoryBoneIdxToPlay = this.init()\n         this.firstMoveAndCorrectBone(mandatoryBoneIdxToPlay)\n\n    }\n\n    //Changes currentPlayer to the next player\n    nextPlayerAssignTurn(){\n       \n        let idxCurrPlayer ;\n        idxCurrPlayer = this.players.indexOf(this.currentPlayer)   \n\n\n        this.currentPlayer = this.players[((idxCurrPlayer + 1) % this.players.length)]\n\n        console.log(\"NEW CURRENT PLAYER\");\n        console.log(this.currentPlayer.username);\n        this.currentPlayer.revealHand()\n        console.log(\"*************\");\n    }\n\n    makeMove(xPos, center, bone){\n\n        // extracting the far left number on the arena\n        const arenaLeftBoneVal = this.arena[0].boneVal[0];\n        // extracting the far right number on the arena\n        const arenaRightBoneVal = this.arena[this.arena.length-1].boneVal[1];\n        \n        // Player plays left side\n        if(xPos < center){\n            //we use this return of play in update Game in Game.jsx\n           return this.playerPlaysLeft(arenaLeftBoneVal, bone);\n        } else {\n            // Player plays right side\n            return this.playerPlaysRight(arenaRightBoneVal, bone)\n\n        }\n    }\n\n    playerPlaysLeft(arenaLeftBoneVal, bone){\n        //check bottom number of player hand bone first\n        // second test checks top number of player hand bone second\n        if(bone.boneVal[1] != arenaLeftBoneVal && bone.boneVal[0] === arenaLeftBoneVal){\n            bone.boneReverse();\n            this.arena.unshift(bone);\n            console.log(\"played left successfully\");\n            console.log(\"rotate SVG -90 degrees\");\n\n            return true;\n        } else if(bone.boneVal[1] === arenaLeftBoneVal){\n            //bone bottom val playable on left - as is. just rotate svg -90\n            this.arena.unshift(bone);\n            console.log(\"played left successfully\");\n            console.log(\"rotate SVG -90 degrees\");\n\n            return true;\n        } else {\n            // left play not playable - make player draw\n            //******************************* */\n            //******************************* */\n            //******************************* */\n            return false\n        }\n    }\n\n    playerPlaysRight(arenaRightBoneVal, bone){\n        if(bone.boneVal[0] != arenaRightBoneVal && bone.boneVal[1] === arenaRightBoneVal){\n                bone.boneReverse();\n                this.arena.push(bone);\n                console.log(\"played right successfully\");\n                console.log(\"rotate SVG -90 degrees\");\n\n                return true;\n            } else if(bone.boneVal[0] === arenaRightBoneVal){\n                this.arena.push(bone);\n                console.log(\"played right successfully\");\n                console.log(\"rotate SVG -90 degrees\");\n\n                return true;\n            } else {\n                // right play not playable - make player draw\n                //******************************* */\n                //******************************* */\n                //******************************* */\n                return false;\n            }\n    }\n\n    /*\n    ********************************RUNNING GAMEPLAY FUNCTIONS END HERE**************\n    ********************************RUNNING GAMEPLAY FUNCTIONS END HERE**************\n    ********************************RUNNING GAMEPLAY FUNCTIONS END HERE**************\n    ********************************RUNNING GAMEPLAY FUNCTIONS END HERE**************\n    ********************************RUNNING GAMEPLAY FUNCTIONS END HERE**************\n    */\n\n    //Might need AI CLASS of PLAYER\n    firstMoveAI(){\n\n    }\n\n    //Renders Arena for Terminal\n    renderArena(){\n        if (this.arena.length === 0){\n\n            console.log(\"THE~~~ARENA\");\n            console.log(\"[]\");\n            return \"[]\"\n\n        }else{\n            let arenaString = \"\"\n\n            console.log(\"THE~~~ARENA\");\n\n            this.arena.forEach(bone => {\n                arenaString += `[${bone.boneVal[0]}, ${bone.boneVal[1]}], `\n            })\n\n            console.log(`${arenaString}`)\n\n            // return this.arena.map((bone) => {\n            //     return bone.boneVal;\n            // })\n\n\n        }\n        // this.currentPlayer.getPlayerInput()\n    }\n\n}\n// one player\n// let axiosPlayerObj = [{username: \"Steven\"}]\n\n\n//Two players - without AI\n// let axiosPlayerObj = [{username: \"Steven\"}, {username: \"TinyPigOink!\"}]\n\n//with AI\n// let axiosPlayerObj = [{username: \"Steven\"}, {username: \"TinyPigOink!\"}, {username: \"Robot!\", isAI: true } ]\n// let axiosPlayerObj = [{username: \"TinyPigOink!\"}]\n// let b1 = new Board(axiosPlayerObj)\n\n\nmodule.exports = Board;","/Users/yangel/Desktop/capicua/capicua/frontend/src/classes/player.js",[],"/Users/yangel/Desktop/capicua/capicua/frontend/src/components/bone.jsx",[],"/Users/yangel/Desktop/capicua/capicua/frontend/src/components/board.jsx",["103"],"import React from \"react\";\nimport { Stage, Layer, Group} from 'react-konva';\nimport Bone from \"./bone\"\nimport Hand from \"./hand\"\n\nimport { allDominos } from \"./allDominos\"\n\n\nclass Board extends React.Component {\n    constructor(props){\n        super(props)\n\n\n    }\n\n    componentDidMount(){\n        // this.getNums()\n    }\n\n    attachImages(){\n        // const\n    }\n\n    \n\n    render(){\n        const boardDimen = 600;\n\n        const {board} = this.props;\n            // const bone1 =  <Bone src={allDominos[\"01\"]} x={200} y={100}/>\n            // const allDominosArr = Object.values(allDominos);\n\n            // we need the keys of the master obj\n        const allDominosArr = Object.keys(allDominos);\n\n        const boneValToString = (boneVal) => {\n            let firstNumStr = boneVal[0].toString();\n            let secondNumStr = boneVal[1].toString();\n            let boneValStrA = firstNumStr + secondNumStr;\n            let boneValStrB = secondNumStr + firstNumStr;\n\n            // The Idea here is the Top num is always on the left even when\n            // rotated -90 Degrees.\n            // ~\n            // If the bone has been rotated then it is boneValStrB and we\n            // can add rotational Logic to the front End.\n            return [boneValStrA, boneValStrB]\n        }\n            \n            \n        const arena = board.arena.map(bone => {\n\n            let boneStrArr = boneValToString(bone.boneVal);\n\n            const singleBoneVal =  boneStrArr[0]\n            const reactKeyVal = parseInt(singleBoneVal)\n        \n\n            if(bone.isDouble()){\n                debugger\n                return <Bone key={reactKeyVal}\n                draggable={false}\n                src={allDominos[boneStrArr[0]]} />\n            }\n            else if(allDominosArr.includes(boneStrArr[0])){\n                //rotate once -90 degrees\n                return <Bone key={reactKeyVal} src={allDominos[boneStrArr[0]]} />\n            } else {\n                //boneVal has been reversed. Rotate 90 Degrees\n                return <Bone key={reactKeyVal} src={allDominos[boneStrArr[1]]} />\n            }\n\n        })\n            \n            // [src,src,src,src,src,src,src]\n        const currHandLength = board.currentPlayer.hand.length\n        const offSetCenter = ((currHandLength / 2) * 40)  // mult by 40\n\n        const startBoxforHand= ((boardDimen/2) - offSetCenter)\n\n            \n           \n            debugger\n           \n            // the arena is simple to show the current pieces in play\n        return (\n          <div>\n            <Stage className=\"board-game-container\" width={boardDimen} height={boardDimen}>\n                <Layer>\n                    <Group x={285} y={270}>\n                        {arena}\n                    </Group>\n                    <Group x={startBoxforHand} y={540}>\n\n                        <Hand offSetCenter={offSetCenter} board={board} allDominos={allDominos}  boneValToString={boneValToString}  />\n                    </Group>\n                </Layer>\n            </Stage>\n          </div>\n        );\n    }\n}\n\n //         // <img src={process.env.PUBLIC_URL + 'images/profile.svg'} />\n            //     // return <Bone src={domino66}/>\n            //     // return <Bone key={`${bone.boneVal[0]}${bone.boneVal[1]}`} src={process.env.PUBLIC_URL +'images/dominos_pieces_vector_svg/dominos_bone_6:6.svg'}/>\n            //     // return <Bone key={`${bone.boneVal[0]}${bone.boneVal[1]}`} src={\"%PUBLIC_URL%/images/dominos_pieces_vector_svg/dominos_bone_6:6.svg\"}/>\n            // })\n\n\n\n\n\n\n// const dominoPathA = \"/Users/Phidias/Documents/aaobReact/MERN/dominos_pieces_vector-svg\"\n// const dominoPathB = \"../dominos_pieces_vector-svg\"\n\n\n// let allFileNames = []\n// let allDominos = []\n\n// fs.readdir(dominoPathA, (err, files) => {\n//   if (err) {\n//     console.error(\"Could not list the directory.\", err);\n//     process.exit(1);\n//   }\n  \n//   files.forEach(file => {\n//     allFileNames.push(file.toString())\n//     let str = file.split(\":\")\n//     let top = parseInt(str[0][str[0].length-1])\n//     let bottom = parseInt(str[1][0])\n//     let dValue = [top,bottom]\n//     console.log(dValue)\n    \n//     // console.log(str.split())\n//     // allDominos.push(str)\n//     // console.log(allDominos)\n\n\n\n\n//     // arr = [3,1]\n//     // allDominos.forEach(domino => {\n//     // <Bone className=\"domino-size\" value={dValue} dValue={domino} src={dominoFile} draggable=\"true\" x={190}  />\n//     // })\n//   })\n//   debugger\n\n// // TEstbone.props.dValue ==> array [3,1]\n// //   console.log(newFileNames)\n// })\n\nexport default Board;","/Users/yangel/Desktop/capicua/capicua/frontend/src/classes/bone.js",[],"/Users/yangel/Desktop/capicua/capicua/frontend/src/components/allDominos.jsx",[],"/Users/yangel/Desktop/capicua/capicua/frontend/src/index.js",[],"/Users/yangel/Desktop/capicua/capicua/frontend/src/components/hand.jsx",["104"],"import React from \"react\";\n\nimport {Group} from 'react-konva';\n// import useImage from 'use-image';\nimport Bone from \"./bone\"\n\n\n\nclass Hand extends React.Component {\n    // constructor(props){\n    //     super(props)\n\n\n\n    // }\n\n    render(){\n        const {board, allDominos, boneValToString, offSetCenter} = this.props;\n\n        // this will need to be changed to the axios player ID. \n        // SOLELY FOR TESTING...\n        let renderedHand = [];\n\n        if (board){\n            debugger\n            renderedHand = board.currentPlayer.hand.map((bone,idx) => {\n               // [\"34\"]\n               const singleBoneVal =  boneValToString(bone.boneVal)[0]\n               const reactKeyVal = parseInt(singleBoneVal)\n               const initialX = 0;\n\n               //width of domino plus spacing\n               const width = 30 + 10;\n\n                const pos = initialX + (width * idx);\n\n                return <Bone \n                x={pos} \n                offSetCenter={offSetCenter}\n                draggable={true}\n                key={reactKeyVal}\n                src={allDominos[singleBoneVal]}/>    \n            })\n        }\n         return(\n                   <>          \n                 {renderedHand}\n                </>\n         )\n\n    }\n\n}\nexport default Hand;","/Users/yangel/Desktop/capicua/capicua/frontend/src/components/chat/chat.jsx",[],"/Users/yangel/Desktop/capicua/capicua/frontend/src/components/chat/chatMsg.jsx",["105"],"import React from 'react'\n\nexport default ({ name, message }) =>\n  <>\n    <div className=\"send-textarea\">\n      <strong>{name}:</strong> <em>{message}</em>\n    </div>\n  </>","/Users/yangel/Desktop/capicua/capicua/frontend/src/components/chat/chatContext.jsx",[],"/Users/yangel/Desktop/capicua/capicua/frontend/src/components/gameView.jsx",[],"/Users/yangel/Desktop/capicua/capicua/frontend/src/components/splash.jsx",[],"/Users/yangel/Desktop/capicua/capicua/frontend/src/components/gameScore.jsx",[],"/Users/yangel/Desktop/capicua/capicua/frontend/src/components/gameRule.jsx",[],"/Users/yangel/Desktop/capicua/capicua/frontend/src/components/chat/join.js",[],"/Users/yangel/Desktop/capicua/capicua/frontend/src/components/arena.jsx",["106","107"],"import React from \"react\";\nimport Konva from \"konva\";\nimport Bone from \"./bone\";\n\n\n\n\n\n\n\n\n\nclass Arena extends React.Component {\n\n    render(){\n        const {board, boneValToString, allDominos, boardDimen,\n        boneWidth, boneHeight, boneIsRevYPos, boneNotRevYPos } = this.props;\n\n\n        // we need the keys of all possible dominos to be rendered\n        // allDominosArr is then keyed into with boneValToString to retrieve\n        // The appropriate Domino Image\n        const allDominosArr = Object.keys(allDominos);\n\n        //this function returns a bone with the x position always at zero\n        //unless the bone is Reversed. then X is +60 because Konva\n        //offsets +90 degree rotation in the negative x-axis.\n        const isFirstBone = (isDouble, isReversed, boneStrArr, reactKeyVal) => {\n            if (isDouble){\n                return <Bone key={reactKeyVal}\n                draggable={true}\n                x={0}\n                width={boneWidth}\n                height={boneHeight}\n                // offsetX={boneWidth / 2}\n                src={allDominos[boneStrArr[0]]}\n                rotation={0}\n                inArena={true} />\n            } else if (isReversed){\n                //boneVal has been reversed. Rotate 90 Degrees\n                // prop x is shifted 60 pixels to the right because rotation\n                // auto-shifts it 60 pixels to the left??? (due to Konva)\n                return <Bone key={reactKeyVal} \n                    draggable={true}\n                    x={boneHeight}\n                    y={boneIsRevYPos}\n                    width={boneWidth}\n                    height={boneHeight}\n                    src={allDominos[boneStrArr[1]]} \n                    rotation={90}\n                    inArena={true} /> \n            } else {\n                //boneVal is NOT reversed. Rotate -90 Degrees\n                 return <Bone key={reactKeyVal}\n                    draggable={true}\n                    x={0}\n                    y={boneNotRevYPos}\n                    width={boneWidth}\n                    height={boneHeight}\n                    src={allDominos[boneStrArr[0]]}\n                    rotation={-90}\n                    inArena={true} />\n            }\n        }\n\n        const xLengthAllBones = (boneDimenArr, currIdx) => {\n            let totalXPos = 0;\n\n            for(let i = 0; i < currIdx; i++){\n                totalXPos += boneDimenArr[i].x;\n            }\n\n            return totalXPos;\n        }\n\n        const boneDimenArr = [];\n\n        const arena = board.arena.map((bone, idx) => {\n            const boneStrArr = boneValToString(bone.boneVal);\n\n            const singleBoneVal =  boneStrArr[0];\n            const reactKeyVal = parseInt(singleBoneVal);\n\n            const boneXnY = (\n                bone.isDouble() ? {\n                    isDouble: true,\n                    isReversed: false,\n                    boneStrArr: boneStrArr,\n                    reactKeyVal: reactKeyVal,\n                    x: boneWidth,\n                    y: 0} :\n                (bone.isReversed ? {\n                    isDouble: false,\n                    isReversed: true,\n                    boneStrArr: boneStrArr,\n                    reactKeyVal: reactKeyVal,\n                    x: boneHeight,\n                    y: boneIsRevYPos } : \n                    {\n                    isDouble: false,\n                    isReversed: false,\n                    boneStrArr: boneStrArr,\n                    reactKeyVal: reactKeyVal, \n                    x: boneHeight, \n                    y: boneNotRevYPos\n                    })\n                );\n\n            boneDimenArr.push(boneXnY);\n\n        \n            if (idx === 0){\n                // debugger\n                return isFirstBone(\n                     boneDimenArr[0].isDouble,\n                     boneDimenArr[0].isReversed,\n                     boneDimenArr[0].boneStrArr,\n                     boneDimenArr[0].reactKeyVal)\n            } else {\n\n                if (bone.isDouble()){\n                    const totalXPos = xLengthAllBones(boneDimenArr, idx);\n                    console.log(`totalXPOS: ${totalXPos}`)\n\n                    // debugger\n                    return <Bone key={reactKeyVal}\n                    draggable={true}\n                    x={totalXPos}\n                    width={boneWidth}\n                    height={boneHeight}\n                    src={allDominos[boneStrArr[0]]}\n                    rotation={0}\n                    inArena={true} />\n                }\n                else if(allDominosArr.includes(boneStrArr[0])){\n                    // bone is NOT reversed\n                    //rotate once -90 degrees\n                    const totalXPos = xLengthAllBones(boneDimenArr, idx);\n                    // debugger\n                    return <Bone key={reactKeyVal} \n                    draggable={true}\n                    x={totalXPos}\n                    y={boneNotRevYPos}\n                    width={boneWidth}\n                    height={boneHeight}\n                    src={allDominos[boneStrArr[0]]}\n                    rotation={-90}\n                    inArena={true} />\n                } else {\n                    //boneVal has been reversed. Rotate 90 Degrees\n                    const totalXPos = xLengthAllBones(boneDimenArr, idx) + 60;\n                    \n                    // debugger\n                    return <Bone key={reactKeyVal}\n                    draggable={true}\n                    x={totalXPos}\n                    y={boneIsRevYPos}\n                    width={boneWidth}\n                    height={boneHeight}\n                    src={allDominos[boneStrArr[1]]}\n                    rotation={90}\n                    inArena={true} />\n                }\n            }\n\n        })\n\n\n        return (\n            <>\n            {arena}\n            </>\n        )\n    }\n}\n\nexport default Arena;","/Users/yangel/Desktop/capicua/capicua/frontend/src/components/otherHands.jsx",["108","109","110"],"import React from \"react\";\nimport {Group} from 'react-konva';\nimport Bone from \"./bone\"\n\n\n\nclass OtherHands extends React.Component {\n\n\n    render() {\n        const {board, boardDimen, boneWidth,\n            boneHeight, boneValToString, allDominos} = this.props;\n\n        const renderHandFn = (player, offSetCenter, playerIdx, currPlayerIdx) => {\n            // debugger\n            \n         const renderedHand = player.hand.map((bone,idx) => {\n\n            const singleBoneVal =  boneValToString(bone.boneVal)[0]\n            const reactKeyVal = parseInt(singleBoneVal + playerIdx)\n            const initialX = 0;\n            const initialY = 0;\n\n            //width of domino plus spacing\n            const width = boneWidth + 10;\n\n            let pos = initialX + (width * idx);\n\n            // debugger\n            \n            // if ((((currPlayerIdx % board.players.length) + 1) % board.players.length)  === playerIdx % board.players.length){\n            if (((currPlayerIdx + 1) % board.players.length)  === playerIdx % board.players.length){\n\n                pos = initialY + (width * idx);\n\n                // width and height are reversed because the bone is flat\n                return <Bone \n                x={0}\n                y={pos} \n                width={boneHeight}\n                height={boneWidth}\n                boneIdx={idx}\n                offSetCenter={offSetCenter}\n                draggable={true}\n                key={reactKeyVal}\n                src={allDominos[\"cdl\"]}\n                inArena={true}/> \n            } \n            else if(((currPlayerIdx + 2) % board.players.length) === playerIdx % board.players.length){\n            \n                return <Bone \n                x={pos}\n                y={0} \n                width={boneWidth}\n                height={boneHeight}\n                boneIdx={idx}\n                offSetCenter={offSetCenter}\n                draggable={true}\n                key={reactKeyVal}\n                src={allDominos[\"cdt\"]}\n                inArena={true}/> \n            }\n            else if(((currPlayerIdx + 3) % board.players.length) === playerIdx % board.players.length){\n                pos = initialY + (width * idx);\n\n                return <Bone \n                x={0}\n                y={pos} \n                width={boneHeight}\n                height={boneWidth}\n                boneIdx={idx}\n                offSetCenter={offSetCenter}\n                draggable={true}\n                key={reactKeyVal}\n                src={allDominos[\"cdr\"]}\n                inArena={true}/> \n            }\n               \n        })\n\n            return renderedHand\n        }\n\n        const currPlayerIdx = board.players.indexOf(board.currentPlayer);\n\n        const blankDominoToCoveredHands = (numPlayers, currPlayerIdx) => {\n            let player2Idx = null;\n            let player3Idx = null;\n            switch(numPlayers){\n                case 2:\n                    player2Idx = ((currPlayerIdx + 1) % board.players.length);\n                    return {[player2Idx]: \"cdt\",\n                            [currPlayerIdx]: \"cdt\"}\n                case 3:\n                     player2Idx = ((currPlayerIdx + 1) % board.players.length);\n                     player3Idx = ((currPlayerIdx + 2) % board.players.length);\n                    return {[player2Idx]: \"cdl\",\n                            [player3Idx]: \"cdt\",\n                            [currPlayerIdx]: \"cdt\"}\n                case 4:\n\n                default:\n                    return\n            }\n        }\n        \n        // allPlayers[someIdx]\n        //The important thing here is that the index to access allPlayers Obj will\n        // always match the index of the next player (p2) and beyond regardless of\n        // where the currentPlayer index is...\n        const allPlayersDataObj = (numPlayers, currPlayerIdx) => {\n            let allPlayers = {};\n\n            /* all the metadata necessary to populate the hidden hands\n               - offSetCenter is the midpoint of board minus the total width of all bones\n                   to center the hand on the board regardless of length\n                - startBoxforPlayerHand is the start x or start y of this div on\n                  the board. relative to board (x,y) @ (0,0)\n                - renderedHandPlayer is a collection of ImageNodes of the count \n                  of all bones in that players hand.\n            */\n            for(let i = currPlayerIdx; i < (currPlayerIdx + numPlayers); i++){\n                allPlayers[i % numPlayers] = {\n                    playerIdx: null,\n                    player: null,\n                    playerHand: null,\n                    offSetCenter: null,\n                    startBoxforPlayerHand: null,\n                    renderedHandPlayer: null\n                         \n                }\n            }\n\n            // this for loop builds out metadata per player to be accessed later \n            //by the function gnerateHands\n            for(let j = currPlayerIdx; j < (currPlayerIdx + numPlayers); j++){\n\n                allPlayers[j % numPlayers].playerIdx = (j % numPlayers);\n                allPlayers[j % numPlayers].player = board.players[allPlayers[j % numPlayers].playerIdx];\n                allPlayers[j % numPlayers].playerHand = allPlayers[j % numPlayers].player.hand;\n                allPlayers[j % numPlayers].offSetCenter = ((allPlayers[j % numPlayers].playerHand.length / 2) * 40);\n                allPlayers[j % numPlayers].startBoxforPlayerHand = ((boardDimen / 2) - allPlayers[j % numPlayers].offSetCenter);\n                allPlayers[j % numPlayers].renderedHandPlayer = renderHandFn(allPlayers[j % numPlayers].player,\n                         allPlayers[j % numPlayers].offSetCenter,\n                         allPlayers[j % numPlayers].playerIdx, currPlayerIdx)\n                \n                }\n\n            return allPlayers;\n\n        }\n\n        const allPlayers = allPlayersDataObj(board.players.length, currPlayerIdx)\n\n        const generateHands = (numPlayers, websocketsId) => {\n                // debugger\n            \n            // const player2Idx = ((currPlayerIdx + 1) % board.players.length);\n            // const player2 = board.players[player2Idx];\n            // const player2Hand = player2.hand;\n            // const offSetCenterP2 = ((player2Hand.length / 2) * 40);\n            // const startBoxforPlayer2Hand = ((boardDimen / 2) - offSetCenter);  \n\n            // const renderedHandplayer2 = renderHandFn(player2, offSetCenter, player2Idx, \"cdt\")\n            const player2Idx = ((currPlayerIdx + 1) % board.players.length);\n            const player3Idx = ((currPlayerIdx + 2) % board.players.length);\n            const player4Idx = ((currPlayerIdx + 3) % board.players.length);\n            switch(numPlayers){\n                case 2:\n        \n                    return <Group x={0} y={allPlayers[player2Idx].startBoxforPlayerHand}> \n                                {allPlayers[player2Idx].renderedHandPlayer}\n\n                            </Group>\n                case 3:\n                    \n                     return <Group x={0} y={0}>\n                                {/* player on left of board below */}\n                                <Group x={0} y={allPlayers[player2Idx].startBoxforPlayerHand}> \n                                    {allPlayers[player2Idx].renderedHandPlayer}\n                                </Group>\n                                {/* player on top of board below */}\n                                <Group x={allPlayers[player3Idx].startBoxforPlayerHand} y={0}>\n                                    {allPlayers[player3Idx].renderedHandPlayer}\n                                </Group>\n                            </Group>\n                case 4:\n                \n                    return <Group x={0} y={0}>\n                                {/* player on left of board below */}\n                                <Group x={0} y={allPlayers[player2Idx].startBoxforPlayerHand}> \n                                    {allPlayers[player2Idx].renderedHandPlayer}\n                                </Group>\n                                {/* player on top of board below */}\n                                <Group x={allPlayers[player3Idx].startBoxforPlayerHand} y={0}>\n                                    {allPlayers[player3Idx].renderedHandPlayer}\n                                </Group>\n                                {/* player on right of board below */}\n                                <Group x={boardDimen - boneHeight} y={allPlayers[player4Idx].startBoxforPlayerHand}>\n                                    {allPlayers[player4Idx].renderedHandPlayer}\n                                </Group>\n                           </Group>\n\n                default:\n                    return <Group></Group>\n            }\n\n        }\n        let handsToGenerate = null;\n        if(board){\n            handsToGenerate = generateHands(board.players.length);\n\n        }\n\n        return (\n            <>\n            {handsToGenerate}\n            </>\n        )\n    }\n}\n export default OtherHands;\n",{"ruleId":"111","severity":1,"message":"112","line":15,"column":13,"nodeType":"113","messageId":"114","endLine":15,"endColumn":14},{"ruleId":"111","severity":1,"message":"115","line":16,"column":13,"nodeType":"113","messageId":"114","endLine":16,"endColumn":14},{"ruleId":"116","replacedBy":"117"},{"ruleId":"118","replacedBy":"119"},{"ruleId":"120","severity":1,"message":"121","line":21,"column":45,"nodeType":"122","messageId":"123","endLine":21,"endColumn":87},{"ruleId":"111","severity":1,"message":"124","line":4,"column":8,"nodeType":"113","messageId":"114","endLine":4,"endColumn":14},{"ruleId":"125","severity":1,"message":"126","line":200,"column":28,"nodeType":"127","messageId":"128","endLine":200,"endColumn":30},{"ruleId":"125","severity":1,"message":"126","line":224,"column":28,"nodeType":"127","messageId":"128","endLine":224,"endColumn":30},{"ruleId":"129","severity":1,"message":"130","line":10,"column":5,"nodeType":"131","messageId":"132","endLine":14,"endColumn":6},{"ruleId":"111","severity":1,"message":"133","line":3,"column":9,"nodeType":"113","messageId":"114","endLine":3,"endColumn":14},{"ruleId":"134","severity":1,"message":"135","line":3,"column":1,"nodeType":"136","endLine":8,"endColumn":6},{"ruleId":"111","severity":1,"message":"137","line":2,"column":8,"nodeType":"113","messageId":"114","endLine":2,"endColumn":13},{"ruleId":"111","severity":1,"message":"138","line":16,"column":52,"nodeType":"113","messageId":"114","endLine":16,"endColumn":62},{"ruleId":"139","severity":1,"message":"140","line":17,"column":58,"nodeType":"141","messageId":"142","endLine":17,"endColumn":60},{"ruleId":"111","severity":1,"message":"143","line":86,"column":15,"nodeType":"113","messageId":"114","endLine":86,"endColumn":40},{"ruleId":"144","severity":1,"message":"145","line":102,"column":17,"nodeType":"146","messageId":"147","endLine":103,"endColumn":27},"no-unused-vars","'i' is defined but never used.","Identifier","unusedVar","'j' is defined but never used.","no-native-reassign",["148"],"no-negated-in-lhs",["149"],"no-lone-blocks","Nested block is redundant.","BlockStatement","redundantNestedBlock","'bodega' is defined but never used.","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","'Group' is defined but never used.","import/no-anonymous-default-export","Assign arrow function to a variable before exporting as module default","ExportDefaultDeclaration","'Konva' is defined but never used.","'boardDimen' is assigned a value but never used.","array-callback-return","Array.prototype.map() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","'blankDominoToCoveredHands' is assigned a value but never used.","no-fallthrough","Expected a 'break' statement before 'default'.","SwitchCase","default","no-global-assign","no-unsafe-negation"]