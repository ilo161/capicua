[{"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/index.js":"1","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/App.js":"2","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/splash.jsx":"3","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/gameView.jsx":"4","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/game.jsx":"5","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/classes/board.js":"6","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/board.jsx":"7","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/classes/player.js":"8","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/classes/boneyard.js":"9","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/bone.jsx":"10","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/hand.jsx":"11","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/arena.jsx":"12","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/allDominos.jsx":"13","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/otherHands.jsx":"14","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/classes/bone.js":"15","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/chat/join.js":"16","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/chat/chat.jsx":"17","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/chat/chatMsg.jsx":"18","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/chat/chatContext.jsx":"19"},{"size":587,"mtime":1610389819482,"results":"20","hashOfConfig":"21"},{"size":726,"mtime":1609970509930,"results":"22","hashOfConfig":"21"},{"size":3342,"mtime":1609970509944,"results":"23","hashOfConfig":"21"},{"size":231,"mtime":1609970509943,"results":"24","hashOfConfig":"21"},{"size":2280,"mtime":1610163295899,"results":"25","hashOfConfig":"21"},{"size":15065,"mtime":1610389816089,"results":"26","hashOfConfig":"21"},{"size":4069,"mtime":1609970509943,"results":"27","hashOfConfig":"21"},{"size":1849,"mtime":1610387960763,"results":"28","hashOfConfig":"21"},{"size":1669,"mtime":1609261284051,"results":"29","hashOfConfig":"21"},{"size":6522,"mtime":1609973270508,"results":"30","hashOfConfig":"21"},{"size":1364,"mtime":1609970509943,"results":"31","hashOfConfig":"21"},{"size":5885,"mtime":1609970509942,"results":"32","hashOfConfig":"21"},{"size":3444,"mtime":1609970509942,"results":"33","hashOfConfig":"21"},{"size":9087,"mtime":1609970509944,"results":"34","hashOfConfig":"21"},{"size":621,"mtime":1609970509940,"results":"35","hashOfConfig":"21"},{"size":912,"mtime":1609970509942,"results":"36","hashOfConfig":"21"},{"size":1742,"mtime":1609970509941,"results":"37","hashOfConfig":"21"},{"size":172,"mtime":1609261284052,"results":"38","hashOfConfig":"21"},{"size":717,"mtime":1609971631914,"results":"39","hashOfConfig":"21"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"218tk5",{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"51","usedDeprecatedRules":"44"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"54","messages":"55","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"56","usedDeprecatedRules":"44"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"63","usedDeprecatedRules":"44"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"66","usedDeprecatedRules":"44"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"69","usedDeprecatedRules":"44"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"74","usedDeprecatedRules":"44"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"77","messages":"78","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"79","messages":"80","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"81","messages":"82","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"83","usedDeprecatedRules":"44"},{"filePath":"84","messages":"85","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/index.js",[],"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/App.js",[],["86","87"],"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/splash.jsx",[],"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/gameView.jsx",[],"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/game.jsx",["88"],"import React from \"react\";\nimport Board from \"./board\"\nimport BoardObject from \"../classes/board\"\n// const BoardObject = require(\"../classes/board\")\n\n//one player game below\n// const axiosPlayerObj = [{username: \"Steven\"}]\n\n\n// two player below\n// const axiosPlayerObj = [{username: \"Steven\"}, {username: \"TinyPigOink!\"}]\n\n// three player below\n// const axiosPlayerObj = [{username: \"Steven\"}, {username: \"TinyPigOink!\"}, {username: \"idrakeUfake\"} ]\n\n//4 player below\nconst axiosPlayerObj = [{username: \"Steven\"}, {username: \"TinyPigOink!\"}, \n{username: \"idrakeUfake!\"},\n{username: \"prophecy!\"}]\n\nclass Game extends React.Component {\n    constructor(props){\n        super(props)\n        const board = new BoardObject(axiosPlayerObj)\n        this.state = {board: board}\n        this.updateGame = this.updateGame.bind(this);\n    }\n\n    componentDidMount(){\n        console.log(this.state.board)\n\n    }\n\n    updateGame(xPosPlay, center, boneIdx) { {/* connected to Tile Component line 8 */}\n        // here to check state. of playable Bone\n        // ...\n        const currentBone = this.state.board.currentPlayer.hand.splice(boneIdx,1)[0];\n        const verifyMove = this.state.board.makeMove(xPosPlay, center, currentBone);\n        this.setState({ state: this.state });\n\n        if(verifyMove){\n            // debugger\n            this.state.board.resetSkipCounter();\n            this.state.board.currentGameOver()\n            if (this.state.board.inSession === true){            \n                this.state.board.nextPlayerAssignTurn()\n                this.setState({ board: this.state.board });\n            }\n        }else {\n            // debugger\n            this.state.board.currentPlayer.hand.splice(boneIdx,0, currentBone); \n            this.setState({ board: this.state.board });\n\n            // this.forceUpdate();\n        }\n        \n        //three arguments xPos, center, bone)\n        console.log(this.state.board.renderArena())\n        console.log(\"Arena ^..hand below\")\n        console.log(this.state.board.currentPlayer.revealHand())\n    }\n\n    render(){\n        \n\n        return (\n            <div className=\"board-container\">\n                <Board board={this.state.board} updateGame={this.updateGame}/>\n            </div>\n        )\n    }\n\n}\n\nexport default Game;","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/classes/board.js",["89","90","91"],"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/board.jsx",["92","93"],"import React from \"react\";\nimport Konva from \"konva\"\nimport { Stage, Layer, Group} from 'react-konva';\nimport Bone from \"./bone\"\nimport Hand from \"./hand\"\nimport Arena from \"./arena\"\nimport OtherHands from \"./otherHands\"\n\nimport { allDominos } from \"./allDominos\"\n\n\nclass Board extends React.Component {\n    constructor(props){\n        super(props)\n\n\n    }\n\n    componentDidMount(){\n        // this.getNums()\n    }\n\n    attachImages(){\n        // const\n    }\n\n    \n\n    render(){\n        const boardDimen = 900;\n        const boneWidth = 30;\n        const boneHeight = 60;\n        const boneIsRevYPos = (boneWidth / 2);\n        const boneNotRevYPos = ((boneWidth / 2) * 3);\n\n        const {board} = this.props;\n\n        const capDom = [<Bone key={\"cd\"}\n                    draggable={true}\n                    x={0}\n                    width={boneWidth}\n                    height={boneHeight}\n                    offsetX={boneWidth / 2}\n                    offsetY={boneHeight / 2}\n                    src={allDominos[\"cd\"]}\n                    rotation={0}\n                    inArena={true} />]\n\n        \n\n        // these 3 lines are required to center the arena in the middle of the board\n        // for Konva Group\n        const currArenaLength = board.arena.length\n        const offSetCenterArena = ((currArenaLength / 2) * boneWidth)  // mult by 40\n        const startBoxforArena = ((boardDimen / 2) - offSetCenterArena)\n\n        const boneValToString = (boneVal) => {\n            let firstNumStr = boneVal[0].toString();\n            let secondNumStr = boneVal[1].toString();\n            let boneValStrA = firstNumStr + secondNumStr;\n            let boneValStrB = secondNumStr + firstNumStr;\n\n            // The Idea here is the Top num is always on the left even when\n            // rotated -90 Degrees.\n            // ~\n            // If the bone has been rotated then it is boneValStrB and we\n            // can add rotational Logic to the front End.\n            return [boneValStrA, boneValStrB]\n        }\n\n        \n\n            \n        // These will determine the length of the playerID owner's hand and render them\n        // centered in the right place. We use startBoxforHand to pick a \n        // startX for the rendering of <Hand></Hand>\n        const currHandLength = board.currentPlayer.hand.length\n        // mult by 40 because width of bone is 30 plus 10 more pixels of space\n        const offSetCenter = ((currHandLength / 2) * boneWidth + 10)  \n\n        const startBoxforHand = ((boardDimen / 2) - offSetCenter)\n\n            \n           \n            // the arena is simply to show the current pieces in play\n        return (\n            <div className=\"board-game-container\">\n            <Stage width={boardDimen} height={boardDimen}>\n                <Layer>\n                    <Group x={startBoxforArena} y={(boardDimen / 2) - boneHeight}>\n                        <Arena board={board} boardDimen={boardDimen}\n                         allDominos={allDominos} boneValToString={boneValToString}\n                         boneWidth={boneWidth} boneHeight={boneHeight}\n                         boneIsRevYPos={boneIsRevYPos}\n                         boneNotRevYPos={boneNotRevYPos}/>\n                    </Group>\n                    <Group x={startBoxforArena} y={(boardDimen / 2) + 60}>\n                        {capDom}\n                    </Group>\n                    <OtherHands board={board} boardDimen={boardDimen} allDominos={allDominos}\n                    boneWidth={boneWidth} boneHeight={boneHeight} boneValToString={boneValToString}/>\n                    <Group x={startBoxforHand} y={boardDimen - boneHeight}>\n\n                        <Hand offSetCenter={offSetCenter} board={board}\n                        boneWidth={boneWidth} boneHeight={boneHeight} \n                        updateGame={this.props.updateGame} allDominos={allDominos}\n                        boneValToString={boneValToString}  />\n                    </Group>\n                </Layer>\n            </Stage>\n          </div>\n        );\n    }\n}\n\n\n\n\n\n\nexport default Board;","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/classes/player.js",["94"],"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/classes/boneyard.js",[],"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/bone.jsx",["95","96"],"import React from \"react\";\nimport {Image} from 'react-konva';\n\nclass Bone extends React.Component {\n    constructor(props){\n        super(props)\n\n        this.state = {\n             image: null,\n             draggable: null,\n             offSetCenter: null,\n             updateGame: null,\n             boneIdx: null,\n             rotation: null,\n             inArena: null,\n             x: null,\n             y: null,\n             width: null,\n             height: null,\n             offsetX: this.props.offsetX,\n             offsetY: this.props.offsetY\n        };\n\n\n    }\n    \n  componentDidMount() {\n\n    // debugger\n    // this.to({\n    //   scaleX: -this.scaleX(),\n    // });\n\n    this.loadImage();\n\n    // console.log(this.imageNode.getPosition());\n  }\n\n  componentDidUpdate(oldProps) {\n\n    if (oldProps.src !== this.props.src) {\n      this.loadImage();\n    } else if(oldProps.x !== this.props.x){\n      this.loadImage();\n    } \n    // oldProps.x\n    // this.props.x\n  }\n\n  componentWillUnmount() {\n    this.image.removeEventListener('load', this.handleLoad);\n  }\n\n  loadImage() {\n    // save to \"this\" to remove \"load\" handler on unmount\n    this.image = new window.Image();\n    this.image.src = this.props.src;\n    this.image.addEventListener('load', this.handleLoad);\n  }\n\n  handleLoad = () => {\n    // after setState react-konva will update canvas and redraw the layer\n    // because \"image\" property is changed\n    // debugger\n    this.setState({\n      image: this.image,\n      draggable: this.props.draggable,\n      offSetCenter: this.props.offSetCenter,\n      updateGame: this.props.updateGame,\n      boneIdx: this.props.boneIdx,\n      rotation: this.props.rotation,\n      inArena: this.props.inArena,\n      x: this.props.x,\n      y: this.props.y,\n      width: this.props.width,\n      height: this.props.height,\n      offsetX: this.props.offsetX,\n      offsetY: this.props.offsetY\n    });\n    // if you keep same image object during source updates\n    // you will have to update layer manually:\n    this.imageNode.getLayer().batchDraw();\n  };\n\n\n  mouseDownStartCoord(e){\n\n    console.log(`MDX: ${e.target.attrs.x}`)\n    // console.log(`MDY: ${e.target.attrs.y}`)\n    console.log(\"------\")\n  }\n\n  // decides where the player wants to play\n  mouseUpCoord(e, updateGame) {\n        // if(e.target.attrs.y > 150 && e.target.attrs.x > 150){\n        //     e.target.attrs.draggable = false;\n        // }  \n        // \n        const xPosPlay = e.target.attrs.x \n        const center = e.target.attrs.offSetCenter\n        //orig below\n        // const boneIdx = e.target.attrs.boneIdx\n        const boneIdx = e.target.index\n        const yCoord = e.target.attrs.y\n        const onBoardXPos = e.target.absolutePosition().x;\n        const onBoardYPos = e.target.absolutePosition().y;\n        \n        console.log(`BoneIdxIs: ${e.target.attrs.boneIdx}`)\n\n        console.log(`Center: ${e.target.attrs.offSetCenter}`)\n        console.log(`X: ${e.target.attrs.x}`)\n        console.log(`Y: ${e.target.attrs.y}`)\n        //works below\n        // this.state.updateGame(xPosPlay, center, boneIdx)\n        // debugger\n\n        // Remember to remove the left side of IF statement\n        // for testing only\n        // ******************************\n        // ******************************\n        // ******************************\n        // ******************************\n        // ******************************\n        // ******************************\n        // ******************************\n        // if (!this.props.inArena && yCoord < -50){\n          // console.log()\n          //else if (x < 0 || x > 540 && y < 0 || y > 540){\n            // if ((onBoardXPos < 0 || onBoardXPos > 540)\n            // || (onBoardYPos < 0 || onBoardYPos > 540)) {\n            //   debugger\n            //   // this.handleLoad();\n            //   e.currentTarget.getLayer().batchDraw();\n            // }\n            // else\n             if (!this.props.inArena && yCoord < -50) {\n\n              updateGame(xPosPlay, center, boneIdx);\n            }\n            // console.log(e.target)\n    }\n\n    // if(x < 0 || x > 540 && y < 0 || y > 540){\n    //     this.handleLoad();\n    // }\n\n    slideUp(e){\n      // debugger\n      // console.log(this.getPosition())\n      console.log(this.absolutePosition())\n      \n      if(!this.attrs.inArena){\n        // console.log(`X: ${e.target.attrs.x}`)\n        // console.log(`Y: ${e.target.attrs.y}`)\n        // console.log(this.getPosition())\n        // this.absolutePosition()... ^^\n        // setX\n        // setY\n        // scale (X,  Y) // scaleX, scaleY\n        // this.offsetX(20) // works in reverse.\n        // this.offsetY(-20) // works in reverse.\n\n        this.to({\n          scaleX: 1.2,\n          scaleY: 1.2,\n          y: -20,\n          duration: 0.2\n        });\n\n        \n\n        // console.log(this.getPosition())\n        this.getLayer().batchDraw();\n      }\n        \n    }\n\n    slideDown(e){\n      if(!this.attrs.inArena){\n          this.to({\n            scaleX: 1.0,\n            scaleY: 1.0,\n            y: 0,\n            duration: 0.2\n          });\n        this.getLayer().batchDraw();\n      }\n      \n    }\n\n\n  render() {\n\n\n    //old width=25 and height = 45\n    \n    return (\n      <Image\n        x={this.state.x}\n        y={this.state.y}\n        offSetCenter={this.state.offSetCenter}\n        image={this.state.image}\n        width={this.state.width}\n        height={this.state.height}\n        boneIdx={this.state.boneIdx}\n        draggable={this.state.draggable}\n        onMouseDown={this.mouseDownStartCoord}\n        onMouseOver={this.slideUp}\n        onMouseOut={this.slideDown}\n        onDragEnd={(e) => this.mouseUpCoord(e, this.state.updateGame)}\n        rotation={this.state.rotation}\n        inArena={this.state.inArena}\n        ref={node => {\n          this.imageNode = node;\n        }}\n      />\n    );\n  }\n}\n\n\n\n\n\n//         return (\n//             <div >\n//                 <Stage className=\"board-game-container\" width={500} height={500} >\n//                     <Layer>\n                        \n//                         {arr}\n//                         {/* <Image image={domino05} x={100} y={100} width={25} height={45}  /> */}\n//                         {/* <Text>HELLO</Text> */}\n//                         {/* <Rect x={140} y={450} width={200} height={50} fill=\"brown\" draggable=\"false\" /> */}\n                            \n//                     </Layer>\n//                 </Stage>\n//             </div>\n//         );\n//     }\n\n// }\nexport default Bone;\n\n\n\n\n\n","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/hand.jsx",["97"],"import React from \"react\";\nimport {Group} from 'react-konva';\nimport Bone from \"./bone\"\n\n\n\nclass Hand extends React.Component {\n\n\n    render(){\n        const {board, allDominos, boneValToString, offSetCenter,\n        boneWidth, boneHeight} = this.props;\n\n\n        // this will need to be changed to the axios player ID. \n        // SOLELY FOR TESTING...\n        let renderedHand = [];\n\n        if (board){\n\n            renderedHand = board.currentPlayer.hand.map((bone,idx) => {\n\n               const singleBoneVal =  boneValToString(bone.boneVal)[0]\n               const reactKeyVal = parseInt(singleBoneVal)\n               const initialX = 0;\n\n               //width of domino plus spacing\n               const width = (boneWidth + 10);\n\n                const pos = initialX + (width * idx);\n\n                return <Bone \n                x={pos} \n                width={boneWidth}\n                height={boneHeight}\n                updateGame={this.props.updateGame}\n                boneIdx={idx}\n                offSetCenter={offSetCenter}\n                draggable={true}\n                key={reactKeyVal}\n                src={allDominos[singleBoneVal]}\n                inArena={false}/>    \n            })\n\n        }\n\n         return(\n                <>          \n                 {renderedHand}\n                </>\n         )\n\n    }\n\n}\nexport default Hand;","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/arena.jsx",["98","99"],"import React from \"react\";\nimport Konva from \"konva\";\nimport Bone from \"./bone\";\n\n\n\n\n\n\n\n\n\nclass Arena extends React.Component {\n\n    render(){\n        const {board, boneValToString, allDominos, boardDimen,\n        boneWidth, boneHeight, boneIsRevYPos, boneNotRevYPos } = this.props;\n\n\n        // we need the keys of all possible dominos to be rendered\n        // allDominosArr is then keyed into with boneValToString to retrieve\n        // The appropriate Domino Image\n        const allDominosArr = Object.keys(allDominos);\n\n        //this function returns a bone with the x position always at zero\n        //unless the bone is Reversed. then X is +60 because Konva\n        //offsets +90 degree rotation in the negative x-axis.\n        const isFirstBone = (isDouble, isReversed, boneStrArr, reactKeyVal) => {\n            if (isDouble){\n                return <Bone key={reactKeyVal}\n                draggable={true}\n                x={0}\n                width={boneWidth}\n                height={boneHeight}\n                // offsetX={boneWidth / 2}\n                src={allDominos[boneStrArr[0]]}\n                rotation={0}\n                inArena={true} />\n            } else if (isReversed){\n                //boneVal has been reversed. Rotate 90 Degrees\n                // prop x is shifted 60 pixels to the right because rotation\n                // auto-shifts it 60 pixels to the left??? (due to Konva)\n                return <Bone key={reactKeyVal} \n                    draggable={true}\n                    x={boneHeight}\n                    y={boneIsRevYPos}\n                    width={boneWidth}\n                    height={boneHeight}\n                    src={allDominos[boneStrArr[1]]} \n                    rotation={90}\n                    inArena={true} /> \n            } else {\n                //boneVal is NOT reversed. Rotate -90 Degrees\n                 return <Bone key={reactKeyVal}\n                    draggable={true}\n                    x={0}\n                    y={boneNotRevYPos}\n                    width={boneWidth}\n                    height={boneHeight}\n                    src={allDominos[boneStrArr[0]]}\n                    rotation={-90}\n                    inArena={true} />\n            }\n        }\n\n        const xLengthAllBones = (boneDimenArr, currIdx) => {\n            let totalXPos = 0;\n\n            for(let i = 0; i < currIdx; i++){\n                totalXPos += boneDimenArr[i].x;\n            }\n\n            return totalXPos;\n        }\n\n        const boneDimenArr = [];\n\n        const arena = board.arena.map((bone, idx) => {\n            const boneStrArr = boneValToString(bone.boneVal);\n\n            const singleBoneVal =  boneStrArr[0];\n            const reactKeyVal = parseInt(singleBoneVal);\n\n            const boneXnY = (\n                bone.isDouble() ? {\n                    isDouble: true,\n                    isReversed: false,\n                    boneStrArr: boneStrArr,\n                    reactKeyVal: reactKeyVal,\n                    x: boneWidth,\n                    y: 0} :\n                (bone.isReversed ? {\n                    isDouble: false,\n                    isReversed: true,\n                    boneStrArr: boneStrArr,\n                    reactKeyVal: reactKeyVal,\n                    x: boneHeight,\n                    y: boneIsRevYPos } : \n                    {\n                    isDouble: false,\n                    isReversed: false,\n                    boneStrArr: boneStrArr,\n                    reactKeyVal: reactKeyVal, \n                    x: boneHeight, \n                    y: boneNotRevYPos\n                    })\n                );\n\n            boneDimenArr.push(boneXnY);\n\n        \n            if (idx === 0){\n                // debugger\n                return isFirstBone(\n                     boneDimenArr[0].isDouble,\n                     boneDimenArr[0].isReversed,\n                     boneDimenArr[0].boneStrArr,\n                     boneDimenArr[0].reactKeyVal)\n            } else {\n\n                if (bone.isDouble()){\n                    const totalXPos = xLengthAllBones(boneDimenArr, idx);\n                    console.log(`totalXPOS: ${totalXPos}`)\n\n                    // debugger\n                    return <Bone key={reactKeyVal}\n                    draggable={true}\n                    x={totalXPos}\n                    width={boneWidth}\n                    height={boneHeight}\n                    src={allDominos[boneStrArr[0]]}\n                    rotation={0}\n                    inArena={true} />\n                }\n                else if(allDominosArr.includes(boneStrArr[0])){\n                    // bone is NOT reversed\n                    //rotate once -90 degrees\n                    const totalXPos = xLengthAllBones(boneDimenArr, idx);\n                    // debugger\n                    return <Bone key={reactKeyVal} \n                    draggable={true}\n                    x={totalXPos}\n                    y={boneNotRevYPos}\n                    width={boneWidth}\n                    height={boneHeight}\n                    src={allDominos[boneStrArr[0]]}\n                    rotation={-90}\n                    inArena={true} />\n                } else {\n                    //boneVal has been reversed. Rotate 90 Degrees\n                    const totalXPos = xLengthAllBones(boneDimenArr, idx) + 60;\n                    \n                    // debugger\n                    return <Bone key={reactKeyVal}\n                    draggable={true}\n                    x={totalXPos}\n                    y={boneIsRevYPos}\n                    width={boneWidth}\n                    height={boneHeight}\n                    src={allDominos[boneStrArr[1]]}\n                    rotation={90}\n                    inArena={true} />\n                }\n            }\n\n        })\n\n\n        return (\n            <>\n            {arena}\n            </>\n        )\n    }\n}\n\nexport default Arena;","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/allDominos.jsx",[],"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/otherHands.jsx",["100","101","102"],"import React from \"react\";\nimport {Group} from 'react-konva';\nimport Bone from \"./bone\"\n\n\n\nclass OtherHands extends React.Component {\n\n\n    render() {\n        const {board, boardDimen, boneWidth,\n            boneHeight, boneValToString, allDominos} = this.props;\n\n        const renderHandFn = (player, offSetCenter, playerIdx, currPlayerIdx) => {\n            // debugger\n            \n         const renderedHand = player.hand.map((bone,idx) => {\n\n            const singleBoneVal =  boneValToString(bone.boneVal)[0]\n            const reactKeyVal = parseInt(singleBoneVal + playerIdx)\n            const initialX = 0;\n            const initialY = 0;\n\n            //width of domino plus spacing\n            const width = boneWidth + 10;\n\n            let pos = initialX + (width * idx);\n\n            // debugger\n            \n            // if ((((currPlayerIdx % board.players.length) + 1) % board.players.length)  === playerIdx % board.players.length){\n            if (((currPlayerIdx + 1) % board.players.length)  === playerIdx % board.players.length){\n\n                pos = initialY + (width * idx);\n\n                // width and height are reversed because the bone is flat\n                return <Bone \n                x={0}\n                y={pos} \n                width={boneHeight}\n                height={boneWidth}\n                boneIdx={idx}\n                offSetCenter={offSetCenter}\n                draggable={true}\n                key={reactKeyVal}\n                src={allDominos[\"cdl\"]}\n                inArena={true}/> \n            } \n            else if(((currPlayerIdx + 2) % board.players.length) === playerIdx % board.players.length){\n            \n                return <Bone \n                x={pos}\n                y={0} \n                width={boneWidth}\n                height={boneHeight}\n                boneIdx={idx}\n                offSetCenter={offSetCenter}\n                draggable={true}\n                key={reactKeyVal}\n                src={allDominos[\"cdt\"]}\n                inArena={true}/> \n            }\n            else if(((currPlayerIdx + 3) % board.players.length) === playerIdx % board.players.length){\n                pos = initialY + (width * idx);\n\n                return <Bone \n                x={0}\n                y={pos} \n                width={boneHeight}\n                height={boneWidth}\n                boneIdx={idx}\n                offSetCenter={offSetCenter}\n                draggable={true}\n                key={reactKeyVal}\n                src={allDominos[\"cdr\"]}\n                inArena={true}/> \n            }\n               \n        })\n\n            return renderedHand\n        }\n\n        const currPlayerIdx = board.players.indexOf(board.currentPlayer);\n\n        const blankDominoToCoveredHands = (numPlayers, currPlayerIdx) => {\n            let player2Idx = null;\n            let player3Idx = null;\n            switch(numPlayers){\n                case 2:\n                    player2Idx = ((currPlayerIdx + 1) % board.players.length);\n                    return {[player2Idx]: \"cdt\",\n                            [currPlayerIdx]: \"cdt\"}\n                case 3:\n                     player2Idx = ((currPlayerIdx + 1) % board.players.length);\n                     player3Idx = ((currPlayerIdx + 2) % board.players.length);\n                    return {[player2Idx]: \"cdl\",\n                            [player3Idx]: \"cdt\",\n                            [currPlayerIdx]: \"cdt\"}\n                case 4:\n\n                default:\n                    return\n            }\n        }\n        \n        // allPlayers[someIdx]\n        //The important thing here is that the index to access allPlayers Obj will\n        // always match the index of the next player (p2) and beyond regardless of\n        // where the currentPlayer index is...\n        const allPlayersDataObj = (numPlayers, currPlayerIdx) => {\n            let allPlayers = {};\n\n            /* all the metadata necessary to populate the hidden hands\n               - offSetCenter is the midpoint of board minus the total width of all bones\n                   to center the hand on the board regardless of length\n                - startBoxforPlayerHand is the start x or start y of this div on\n                  the board. relative to board (x,y) @ (0,0)\n                - renderedHandPlayer is a collection of ImageNodes of the count \n                  of all bones in that players hand.\n            */\n            for(let i = currPlayerIdx; i < (currPlayerIdx + numPlayers); i++){\n                allPlayers[i % numPlayers] = {\n                    playerIdx: null,\n                    player: null,\n                    playerHand: null,\n                    offSetCenter: null,\n                    startBoxforPlayerHand: null,\n                    renderedHandPlayer: null\n                         \n                }\n            }\n\n            // this for loop builds out metadata per player to be accessed later \n            //by the function gnerateHands\n            for(let j = currPlayerIdx; j < (currPlayerIdx + numPlayers); j++){\n\n                allPlayers[j % numPlayers].playerIdx = (j % numPlayers);\n                allPlayers[j % numPlayers].player = board.players[allPlayers[j % numPlayers].playerIdx];\n                allPlayers[j % numPlayers].playerHand = allPlayers[j % numPlayers].player.hand;\n                allPlayers[j % numPlayers].offSetCenter = ((allPlayers[j % numPlayers].playerHand.length / 2) * 40);\n                allPlayers[j % numPlayers].startBoxforPlayerHand = ((boardDimen / 2) - allPlayers[j % numPlayers].offSetCenter);\n                allPlayers[j % numPlayers].renderedHandPlayer = renderHandFn(allPlayers[j % numPlayers].player,\n                         allPlayers[j % numPlayers].offSetCenter,\n                         allPlayers[j % numPlayers].playerIdx, currPlayerIdx)\n                \n                }\n\n            return allPlayers;\n\n        }\n\n        const allPlayers = allPlayersDataObj(board.players.length, currPlayerIdx)\n\n        const generateHands = (numPlayers, websocketsId) => {\n                // debugger\n            \n            // const player2Idx = ((currPlayerIdx + 1) % board.players.length);\n            // const player2 = board.players[player2Idx];\n            // const player2Hand = player2.hand;\n            // const offSetCenterP2 = ((player2Hand.length / 2) * 40);\n            // const startBoxforPlayer2Hand = ((boardDimen / 2) - offSetCenter);  \n\n            // const renderedHandplayer2 = renderHandFn(player2, offSetCenter, player2Idx, \"cdt\")\n            const player2Idx = ((currPlayerIdx + 1) % board.players.length);\n            const player3Idx = ((currPlayerIdx + 2) % board.players.length);\n            const player4Idx = ((currPlayerIdx + 3) % board.players.length);\n            switch(numPlayers){\n                case 2:\n        \n                    return <Group x={0} y={allPlayers[player2Idx].startBoxforPlayerHand}> \n                                {allPlayers[player2Idx].renderedHandPlayer}\n\n                            </Group>\n                case 3:\n                    \n                     return <Group x={0} y={0}>\n                                {/* player on left of board below */}\n                                <Group x={0} y={allPlayers[player2Idx].startBoxforPlayerHand}> \n                                    {allPlayers[player2Idx].renderedHandPlayer}\n                                </Group>\n                                {/* player on top of board below */}\n                                <Group x={allPlayers[player3Idx].startBoxforPlayerHand} y={0}>\n                                    {allPlayers[player3Idx].renderedHandPlayer}\n                                </Group>\n                            </Group>\n                case 4:\n                \n                    return <Group x={0} y={0}>\n                                {/* player on left of board below */}\n                                <Group x={0} y={allPlayers[player2Idx].startBoxforPlayerHand}> \n                                    {allPlayers[player2Idx].renderedHandPlayer}\n                                </Group>\n                                {/* player on top of board below */}\n                                <Group x={allPlayers[player3Idx].startBoxforPlayerHand} y={0}>\n                                    {allPlayers[player3Idx].renderedHandPlayer}\n                                </Group>\n                                {/* player on right of board below */}\n                                <Group x={boardDimen - boneHeight} y={allPlayers[player4Idx].startBoxforPlayerHand}>\n                                    {allPlayers[player4Idx].renderedHandPlayer}\n                                </Group>\n                           </Group>\n\n                default:\n                    return <Group></Group>\n            }\n\n        }\n        let handsToGenerate = null;\n        if(board){\n            handsToGenerate = generateHands(board.players.length);\n\n        }\n\n        return (\n            <>\n            {handsToGenerate}\n            </>\n        )\n    }\n}\n export default OtherHands;\n","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/classes/bone.js",[],"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/chat/join.js",[],"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/chat/chat.jsx",[],"/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/chat/chatMsg.jsx",["103"],"import React from 'react'\n\nexport default ({ name, message }) =>\n  <>\n    <div className=\"send-textarea\">\n      <strong>{name}:</strong> <em>{message}</em>\n    </div>\n  </>","/Users/vault/Desktop/AA work/Capicua/capicua/frontend/src/components/chat/chatContext.jsx",[],{"ruleId":"104","replacedBy":"105"},{"ruleId":"106","replacedBy":"107"},{"ruleId":"108","severity":1,"message":"109","line":34,"column":45,"nodeType":"110","messageId":"111","endLine":34,"endColumn":87},{"ruleId":"112","severity":1,"message":"113","line":6,"column":1,"nodeType":"114","messageId":"115","endLine":17,"endColumn":2},{"ruleId":"116","severity":1,"message":"117","line":404,"column":58,"nodeType":"118","messageId":"119","endLine":404,"endColumn":59},{"ruleId":"116","severity":1,"message":"117","line":404,"column":68,"nodeType":"118","messageId":"119","endLine":404,"endColumn":69},{"ruleId":"120","severity":1,"message":"121","line":2,"column":8,"nodeType":"122","messageId":"123","endLine":2,"endColumn":13},{"ruleId":"124","severity":1,"message":"125","line":13,"column":5,"nodeType":"126","messageId":"127","endLine":17,"endColumn":6},{"ruleId":"120","severity":1,"message":"128","line":41,"column":13,"nodeType":"122","messageId":"123","endLine":41,"endColumn":20},{"ruleId":"120","severity":1,"message":"129","line":105,"column":15,"nodeType":"122","messageId":"123","endLine":105,"endColumn":26},{"ruleId":"120","severity":1,"message":"130","line":106,"column":15,"nodeType":"122","messageId":"123","endLine":106,"endColumn":26},{"ruleId":"120","severity":1,"message":"131","line":2,"column":9,"nodeType":"122","messageId":"123","endLine":2,"endColumn":14},{"ruleId":"120","severity":1,"message":"121","line":2,"column":8,"nodeType":"122","messageId":"123","endLine":2,"endColumn":13},{"ruleId":"120","severity":1,"message":"132","line":16,"column":52,"nodeType":"122","messageId":"123","endLine":16,"endColumn":62},{"ruleId":"133","severity":1,"message":"134","line":17,"column":58,"nodeType":"135","messageId":"136","endLine":17,"endColumn":60},{"ruleId":"120","severity":1,"message":"137","line":86,"column":15,"nodeType":"122","messageId":"123","endLine":86,"endColumn":40},{"ruleId":"138","severity":1,"message":"139","line":102,"column":17,"nodeType":"140","messageId":"141","endLine":103,"endColumn":27},{"ruleId":"142","severity":1,"message":"143","line":3,"column":1,"nodeType":"144","endLine":8,"endColumn":6},"no-native-reassign",["145"],"no-negated-in-lhs",["146"],"no-lone-blocks","Nested block is redundant.","BlockStatement","redundantNestedBlock","no-extend-native","Array prototype is read only, properties should not be added.","AssignmentExpression","unexpected","no-useless-concat","Unexpected string concatenation of literals.","BinaryExpression","unexpectedConcat","no-unused-vars","'Konva' is defined but never used.","Identifier","unusedVar","no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","'newBone' is assigned a value but never used.","'onBoardXPos' is assigned a value but never used.","'onBoardYPos' is assigned a value but never used.","'Group' is defined but never used.","'boardDimen' is assigned a value but never used.","array-callback-return","Array.prototype.map() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","'blankDominoToCoveredHands' is assigned a value but never used.","no-fallthrough","Expected a 'break' statement before 'default'.","SwitchCase","default","import/no-anonymous-default-export","Assign arrow function to a variable before exporting as module default","ExportDefaultDeclaration","no-global-assign","no-unsafe-negation"]